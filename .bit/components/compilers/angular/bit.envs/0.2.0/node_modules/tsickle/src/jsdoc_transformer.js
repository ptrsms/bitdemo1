/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/jsdoc_transformer", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/decorators", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/module_type_translator", "tsickle/src/transformer_util", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview jsdoc_transformer contains the logic to add JSDoc comments to TypeScript code.
     *
     * One of tsickle's features is to add Closure Compiler compatible JSDoc comments containing type
     * annotations, inheritance information, etc., onto TypeScript code. This allows Closure Compiler to
     * make better optimization decisions compared to an untyped code base.
     *
     * The entry point to the annotation operation is jsdocTransformer below. It adds synthetic comments
     * to existing TypeScript constructs, for example:
     *     const x: number = 1;
     * Might get transformed to:
     *     /.. \@type {number} ./
     *     const x: number = 1;
     * Later TypeScript phases then remove the type annotation, and the final emit is JavaScript that
     * only contains the JSDoc comment.
     *
     * To handle certain constructs, this transformer also performs AST transformations, e.g. by adding
     * CommonJS-style exports for type constructs, expanding `export *`, parenthesizing casts, etc.
     */
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const decorators_1 = require("tsickle/src/decorators");
    const googmodule = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const module_type_translator_1 = require("tsickle/src/module_type_translator");
    const transformerUtil = require("tsickle/src/transformer_util");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const type_translator_1 = require("tsickle/src/type_translator");
    function addCommentOn(node, tags, escapeExtraTags) {
        const comment = jsdoc.toSynthesizedComment(tags, escapeExtraTags);
        const comments = ts.getSyntheticLeadingComments(node) || [];
        comments.push(comment);
        ts.setSyntheticLeadingComments(node, comments);
        return comment;
    }
    /** Adds an \@template clause to docTags if decl has type parameters. */
    function maybeAddTemplateClause(docTags, decl) {
        if (!decl.typeParameters)
            return;
        // Closure does not support template constraints (T extends X), these are ignored below.
        docTags.push({
            tagName: 'template',
            text: decl.typeParameters.map(tp => transformerUtil.getIdentifierText(tp.name)).join(', ')
        });
    }
    exports.maybeAddTemplateClause = maybeAddTemplateClause;
    /**
     * Adds heritage clauses (\@extends, \@implements) to the given docTags for decl. Used by
     * jsdoc_transformer and externs generation.
     */
    function maybeAddHeritageClauses(docTags, mtt, decl) {
        if (!decl.heritageClauses)
            return;
        const isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;
        const hasExtends = decl.heritageClauses.some(c => c.token === ts.SyntaxKind.ExtendsKeyword);
        for (const heritage of decl.heritageClauses) {
            const isExtends = heritage.token === ts.SyntaxKind.ExtendsKeyword;
            if (isClass && isExtends) {
                // If a class has an "extends", that is preserved in the ES6 output
                // and we don't need to emit any additional jsdoc.
                //
                // However for ambient declarations, we only emit externs, and in those we do need to
                // add "@extends {Foo}" as they use ES5 syntax.
                if (!transformerUtil.isAmbient(decl))
                    continue;
            }
            // Otherwise, if we get here, we need to emit some jsdoc.
            for (const expr of heritage.types) {
                const heritage = heritageName(isExtends, hasExtends, expr);
                // heritageName may return null, indicating that the clause is something inexpressible
                // in Closure, e.g. "class Foo implements Partial<Bar>".
                if (heritage) {
                    docTags.push({
                        tagName: heritage.tagName,
                        type: heritage.parentName,
                    });
                }
            }
        }
        /**
         * Computes the Closure name of an expression occurring in a heritage clause,
         * e.g. "implements FooBar".  Will return null if the expression is inexpressible
         * in Closure semantics.  Note that we don't need to consider all possible
         * combinations of types/values and extends/implements because our input is
         * already verified to be valid TypeScript.  See test_files/class/ for the full
         * cartesian product of test cases.
         * @param isExtends True if we're in an 'extends', false in an 'implements'.
         * @param hasExtends True if there are any 'extends' clauses present at all.
         */
        function heritageName(isExtends, hasExtends, expr) {
            let tagName = isExtends ? 'extends' : 'implements';
            let sym = mtt.typeChecker.getSymbolAtLocation(expr.expression);
            if (!sym) {
                // It's possible for a class declaration to extend an expression that
                // does not have have a symbol, for example when a mixin function is
                // used to build a base class, as in `declare MyClass extends
                // MyMixin(MyBaseClass)`.
                //
                // Handling this correctly is tricky. Closure throws on this
                // `extends <expression>` syntax (see
                // https://github.com/google/closure-compiler/issues/2182). We would
                // probably need to generate an intermediate class declaration and
                // extend that.
                mtt.debugWarn(decl, `could not resolve supertype: ${expr.getText()}`);
                return null;
            }
            // Resolve any aliases to the underlying type.
            if (sym.flags & ts.SymbolFlags.TypeAlias) {
                // It's implementing a type alias.  Follow the type alias back
                // to the original symbol to check whether it's a type or a value.
                const type = mtt.typeChecker.getDeclaredTypeOfSymbol(sym);
                if (!type.symbol) {
                    // It's not clear when this can happen.
                    mtt.debugWarn(decl, `could not get type of symbol: ${expr.getText()}`);
                    return null;
                }
                sym = type.symbol;
            }
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = mtt.typeChecker.getAliasedSymbol(sym);
            }
            const typeTranslator = mtt.newTypeTranslator(expr.expression);
            if (typeTranslator.isBlackListed(sym)) {
                // Don't emit references to blacklisted types.
                return null;
            }
            if (sym.flags & ts.SymbolFlags.Class) {
                if (!isClass) {
                    // Closure interfaces cannot extend or implements classes.
                    mtt.debugWarn(decl, `omitting interface deriving from class: ${expr.getText()}`);
                    return null;
                }
                if (!isExtends) {
                    if (!hasExtends) {
                        // A special case: for a class that has no existing 'extends' clause but does
                        // have an 'implements' clause that refers to another class, we change it to
                        // instead be an 'extends'.  This was a poorly-thought-out hack that may
                        // actually cause compiler bugs:
                        //   https://github.com/google/closure-compiler/issues/3126
                        // but we have code that now relies on it, ugh.
                        tagName = 'extends';
                    }
                    else {
                        // Closure can only @implements an interface, not a class.
                        mtt.debugWarn(decl, `omitting @implements of a class: ${expr.getText()}`);
                        return null;
                    }
                }
            }
            else if (sym.flags & ts.SymbolFlags.Value) {
                // If it's something other than a class in the value namespace, then it will
                // not be a type in the Closure output (because Closure collapses
                // the type and value namespaces).
                mtt.debugWarn(decl, `omitting heritage reference to a type/value conflict: ${expr.getText()}`);
                return null;
            }
            else if (sym.flags & ts.SymbolFlags.TypeLiteral) {
                // A type literal is a type like `{foo: string}`.
                // These can come up as the output of a mapped type.
                mtt.debugWarn(decl, `omitting heritage reference to a type literal: ${expr.getText()}`);
                return null;
            }
            // typeToClosure includes nullability modifiers, so call symbolToString directly here.
            const parentName = typeTranslator.symbolToString(sym);
            if (!parentName)
                return null;
            return { tagName, parentName };
        }
    }
    exports.maybeAddHeritageClauses = maybeAddHeritageClauses;
    /**
     * createMemberTypeDeclaration emits the type annotations for members of a class. It's necessary in
     * the case where TypeScript syntax specifies there are additional properties on the class, because
     * to declare these in Closure you must declare these separately from the class.
     *
     * createMemberTypeDeclaration produces an if (false) statement containing property declarations, or
     * null if no declarations could or needed to be generated (e.g. no members, or an unnamed type).
     * The if statement is used to make sure the code is not executed, otherwise property accesses could
     * trigger getters on a superclass. See test_files/fields/fields.ts:BaseThatThrows.
     */
    function createMemberTypeDeclaration(mtt, typeDecl) {
        // Gather parameter properties from the constructor, if it exists.
        const ctors = [];
        let paramProps = [];
        const nonStaticProps = [];
        const staticProps = [];
        const unhandled = [];
        const abstractMethods = [];
        for (const member of typeDecl.members) {
            if (member.kind === ts.SyntaxKind.Constructor) {
                ctors.push(member);
            }
            else if (ts.isPropertyDeclaration(member) || ts.isPropertySignature(member)) {
                const isStatic = transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Static);
                if (isStatic) {
                    staticProps.push(member);
                }
                else {
                    nonStaticProps.push(member);
                }
            }
            else if (member.kind === ts.SyntaxKind.MethodDeclaration ||
                member.kind === ts.SyntaxKind.MethodSignature ||
                member.kind === ts.SyntaxKind.GetAccessor || member.kind === ts.SyntaxKind.SetAccessor) {
                if (transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Abstract) ||
                    ts.isInterfaceDeclaration(typeDecl)) {
                    abstractMethods.push(member);
                }
                // Non-abstract methods only exist on classes, and are handled in regular emit.
            }
            else {
                unhandled.push(member);
            }
        }
        if (ctors.length > 0) {
            // Only the actual constructor implementation, which must be last in a potential sequence of
            // overloaded constructors, may contain parameter properties.
            const ctor = ctors[ctors.length - 1];
            paramProps = ctor.parameters.filter(p => transformerUtil.hasModifierFlag(p, ts.ModifierFlags.ParameterPropertyModifier));
        }
        if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&
            abstractMethods.length === 0) {
            // There are no members so we don't need to emit any type
            // annotations helper.
            return null;
        }
        if (!typeDecl.name) {
            mtt.debugWarn(typeDecl, 'cannot add types on unnamed declarations');
            return null;
        }
        const className = transformerUtil.getIdentifierText(typeDecl.name);
        const staticPropAccess = ts.createIdentifier(className);
        const instancePropAccess = ts.createPropertyAccess(staticPropAccess, 'prototype');
        // Closure Compiler will report conformance errors about this being unknown type when emitting
        // class properties as {?|undefined}, instead of just {?}. So make sure to only emit {?|undefined}
        // on interfaces.
        const isInterface = ts.isInterfaceDeclaration(typeDecl);
        const propertyDecls = staticProps.map(p => createClosurePropertyDeclaration(mtt, staticPropAccess, p, isInterface && !!p.questionToken));
        propertyDecls.push(...[...nonStaticProps, ...paramProps].map(p => createClosurePropertyDeclaration(mtt, instancePropAccess, p, isInterface && !!p.questionToken)));
        propertyDecls.push(...unhandled.map(p => transformerUtil.createMultiLineComment(p, `Skipping unhandled member: ${escapeForComment(p.getText())}`)));
        for (const fnDecl of abstractMethods) {
            // If the function declaration is computed, its name is the computed expression; otherwise, its
            // name can be resolved to a string.
            const name = fnDecl.name && ts.isComputedPropertyName(fnDecl.name) ? fnDecl.name.expression :
                propertyName(fnDecl);
            if (!name) {
                mtt.error(fnDecl, 'anonymous abstract function');
                continue;
            }
            const { tags, parameterNames } = mtt.getFunctionTypeJSDoc([fnDecl], []);
            if (decorators_1.hasExportingDecorator(fnDecl, mtt.typeChecker))
                tags.push({ tagName: 'export' });
            // Use element access instead of property access for compued names.
            const lhs = typeof name === 'string' ? ts.createPropertyAccess(instancePropAccess, name) :
                ts.createElementAccess(instancePropAccess, name);
            // memberNamespace because abstract methods cannot be static in TypeScript.
            const abstractFnDecl = ts.createStatement(ts.createAssignment(lhs, ts.createFunctionExpression(
            /* modifiers */ undefined, 
            /* asterisk */ undefined, 
            /* name */ undefined, 
            /* typeParameters */ undefined, parameterNames.map(n => ts.createParameter(
            /* decorators */ undefined, /* modifiers */ undefined, 
            /* dotDotDot */ undefined, n)), undefined, ts.createBlock([]))));
            ts.setSyntheticLeadingComments(abstractFnDecl, [jsdoc.toSynthesizedComment(tags)]);
            propertyDecls.push(ts.setSourceMapRange(abstractFnDecl, fnDecl));
        }
        // See test_files/fields/fields.ts:BaseThatThrows for a note on this wrapper.
        return ts.createIf(ts.createLiteral(false), ts.createBlock(propertyDecls, true));
    }
    function propertyName(prop) {
        if (!prop.name)
            return null;
        switch (prop.name.kind) {
            case ts.SyntaxKind.Identifier:
                return transformerUtil.getIdentifierText(prop.name);
            case ts.SyntaxKind.StringLiteral:
                // E.g. interface Foo { 'bar': number; }
                // If 'bar' is a name that is not valid in Closure then there's nothing we can do.
                const text = prop.name.text;
                if (!type_translator_1.isValidClosurePropertyName(text))
                    return null;
                return text;
            default:
                return null;
        }
    }
    /** Removes comment metacharacters from a string, to make it safe to embed in a comment. */
    function escapeForComment(str) {
        return str.replace(/\/\*/g, '__').replace(/\*\//g, '__');
    }
    exports.escapeForComment = escapeForComment;
    function createClosurePropertyDeclaration(mtt, expr, prop, optional) {
        const name = propertyName(prop);
        if (!name) {
            mtt.debugWarn(prop, `handle unnamed member:\n${escapeForComment(prop.getText())}`);
            return transformerUtil.createMultiLineComment(prop, `Skipping unnamed member:\n${escapeForComment(prop.getText())}`);
        }
        let type = mtt.typeToClosure(prop);
        // When a property is optional, e.g.
        //   foo?: string;
        // Then the TypeScript type of the property is string|undefined, the
        // typeToClosure translation handles it correctly, and string|undefined is
        // how you write an optional property in Closure.
        //
        // But in the special case of an optional property with type any:
        //   foo?: any;
        // The TypeScript type of the property is just "any" (because any includes
        // undefined as well) so our default translation of the type is just "?".
        // To mark the property as optional in Closure it must have "|undefined",
        // so the Closure type must be ?|undefined.
        if (optional && type === '?')
            type += '|undefined';
        const tags = mtt.getJSDoc(prop, /* reportWarnings */ true);
        tags.push({ tagName: 'type', type });
        const flags = ts.getCombinedModifierFlags(prop);
        if (flags & ts.ModifierFlags.Protected) {
            tags.push({ tagName: 'protected' });
        }
        else if (flags & ts.ModifierFlags.Private) {
            tags.push({ tagName: 'private' });
        }
        if (decorators_1.hasExportingDecorator(prop, mtt.typeChecker)) {
            tags.push({ tagName: 'export' });
        }
        const declStmt = ts.setSourceMapRange(ts.createStatement(ts.createPropertyAccess(expr, name)), prop);
        // Avoid printing annotations that can conflict with @type
        // This avoids Closure's error "type annotation incompatible with other annotations"
        addCommentOn(declStmt, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
        return declStmt;
    }
    /**
     * Removes any type assertions and non-null expressions from the AST before TypeScript processing.
     *
     * Ideally, the code in jsdoc_transformer below should just remove the cast expression and
     * replace it with the Closure equivalent. However Angular's compiler is fragile to AST
     * nodes being removed or changing type, so the code must retain the type assertion
     * expression, see: https://github.com/angular/angular/issues/24895.
     *
     * tsickle also cannot just generate and keep a `(/.. @type {SomeType} ./ (expr as SomeType))`
     * because TypeScript removes the parenthesized expressions in that syntax, (reasonably) believing
     * they were only added for the TS cast.
     *
     * The final workaround is then to keep the TypeScript type assertions, and have a post-Angular
     * processing step that removes the assertions before TypeScript sees them.
     *
     * TODO(martinprobst): remove once the Angular issue is fixed.
     */
    function removeTypeAssertions() {
        return (context) => {
            return (sourceFile) => {
                function visitor(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.TypeAssertionExpression:
                        case ts.SyntaxKind.AsExpression:
                            return ts.visitNode(node.expression, visitor);
                        case ts.SyntaxKind.NonNullExpression:
                            return ts.visitNode(node.expression, visitor);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                return visitor(sourceFile);
            };
        };
    }
    exports.removeTypeAssertions = removeTypeAssertions;
    /**
     * jsdocTransformer returns a transformer factory that converts TypeScript types into the equivalent
     * JSDoc annotations.
     */
    function jsdocTransformer(host, tsOptions, typeChecker, diagnostics) {
        return (context) => {
            return (sourceFile) => {
                const moduleTypeTranslator = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ false);
                /**
                 * The set of all names exported from an export * in the current module. Used to prevent
                 * emitting duplicated exports. The first export * takes precedence in ES6.
                 */
                const expandedStarImports = new Set();
                /**
                 * While Closure compiler supports parameterized types, including parameterized `this` on
                 * methods, it does not support constraints on them. That means that an `\@template`d type is
                 * always considered to be `unknown` within the method, including `THIS`.
                 *
                 * To help Closure Compiler, we keep track of any templated this return type, and substitute
                 * explicit casts to the templated type.
                 *
                 * This is an incomplete solution and works around a specific problem with warnings on unknown
                 * this accesses. More generally, Closure also cannot infer constraints for any other
                 * templated types, but that might require a more general solution in Closure Compiler.
                 */
                let contextThisType = null;
                function visitClassDeclaration(classDecl) {
                    const contextThisTypeBackup = contextThisType;
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(classDecl);
                    if (transformerUtil.hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {
                        mjsdoc.tags.push({ tagName: 'abstract' });
                    }
                    maybeAddTemplateClause(mjsdoc.tags, classDecl);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(mjsdoc.tags, moduleTypeTranslator, classDecl);
                    }
                    mjsdoc.updateComment();
                    const decls = [];
                    const memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, classDecl);
                    // WARNING: order is significant; we must create the member decl before transforming away
                    // parameter property comments when visiting the constructor.
                    decls.push(ts.visitEachChild(classDecl, visitor, context));
                    if (memberDecl)
                        decls.push(memberDecl);
                    contextThisType = contextThisTypeBackup;
                    return decls;
                }
                /**
                 * visitHeritageClause works around a Closure Compiler issue, where the expression in an
                 * "extends" clause must be a simple identifier, and in particular must not be a parenthesized
                 * expression.
                 *
                 * This is triggered when TS code writes "class X extends (Foo as Bar) { ... }", commonly done
                 * to support mixins. For extends clauses in classes, the code below drops the cast and any
                 * parentheticals, leaving just the original expression.
                 *
                 * This is an incomplete workaround, as Closure will still bail on other super expressions,
                 * but retains compatibility with the previous emit that (accidentally) dropped the cast
                 * expression.
                 *
                 * TODO(martinprobst): remove this once the Closure side issue has been resolved.
                 */
                function visitHeritageClause(heritageClause) {
                    if (heritageClause.token !== ts.SyntaxKind.ExtendsKeyword || !heritageClause.parent ||
                        heritageClause.parent.kind === ts.SyntaxKind.InterfaceDeclaration) {
                        return ts.visitEachChild(heritageClause, visitor, context);
                    }
                    if (heritageClause.types.length !== 1) {
                        moduleTypeTranslator.error(heritageClause, `expected exactly one type in class extension clause`);
                    }
                    const type = heritageClause.types[0];
                    let expr = type.expression;
                    while (ts.isParenthesizedExpression(expr) || ts.isNonNullExpression(expr) ||
                        ts.isAssertionExpression(expr)) {
                        expr = expr.expression;
                    }
                    return ts.updateHeritageClause(heritageClause, [ts.updateExpressionWithTypeArguments(type, type.typeArguments || [], expr)]);
                }
                function visitInterfaceDeclaration(iface) {
                    const sym = typeChecker.getSymbolAtLocation(iface.name);
                    if (!sym) {
                        moduleTypeTranslator.error(iface, 'interface with no symbol');
                        return [];
                    }
                    // If this symbol is both a type and a value, we cannot emit both into Closure's
                    // single namespace.
                    if (transformer_util_1.symbolIsValue(typeChecker, sym)) {
                        moduleTypeTranslator.debugWarn(iface, `type/symbol conflict for ${sym.name}, using {?} for now`);
                        return [transformerUtil.createSingleLineComment(iface, 'WARNING: interface has both a type and a value, skipping emit')];
                    }
                    const tags = moduleTypeTranslator.getJSDoc(iface, /* reportWarnings */ true) || [];
                    tags.push({ tagName: 'record' });
                    maybeAddTemplateClause(tags, iface);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(tags, moduleTypeTranslator, iface);
                    }
                    const name = transformerUtil.getIdentifierText(iface.name);
                    const modifiers = transformerUtil.hasModifierFlag(iface, ts.ModifierFlags.Export) ?
                        [ts.createToken(ts.SyntaxKind.ExportKeyword)] :
                        undefined;
                    const decl = ts.setSourceMapRange(ts.createFunctionDeclaration(
                    /* decorators */ undefined, modifiers, 
                    /* asterisk */ undefined, name, 
                    /* typeParameters */ undefined, 
                    /* parameters */ [], 
                    /* type */ undefined, 
                    /* body */ ts.createBlock([])), iface);
                    addCommentOn(decl, tags);
                    const memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, iface);
                    return memberDecl ? [decl, memberDecl] : [decl];
                }
                /** Function declarations are emitted as they are, with only JSDoc added. */
                function visitFunctionLikeDeclaration(fnDecl) {
                    if (!fnDecl.body) {
                        // Two cases: abstract methods and overloaded methods/functions.
                        // Abstract methods are handled in emitTypeAnnotationsHandler.
                        // Overloads are union-ized into the shared type in FunctionType.
                        return ts.visitEachChild(fnDecl, visitor, context);
                    }
                    const extraTags = [];
                    if (decorators_1.hasExportingDecorator(fnDecl, typeChecker))
                        extraTags.push({ tagName: 'export' });
                    const { tags, thisReturnType } = moduleTypeTranslator.getFunctionTypeJSDoc([fnDecl], extraTags);
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(fnDecl);
                    mjsdoc.tags = tags;
                    mjsdoc.updateComment();
                    const contextThisTypeBackup = contextThisType;
                    // Arrow functions retain their context `this` type. All others reset the this type to
                    // either none (if not specified) or the type given in a fn(this: T, ...) declaration.
                    if (!ts.isArrowFunction(fnDecl))
                        contextThisType = thisReturnType;
                    const result = ts.visitEachChild(fnDecl, visitor, context);
                    contextThisType = contextThisTypeBackup;
                    return result;
                }
                /**
                 * In methods with a templated this type, adds explicit casts to accesses on this.
                 *
                 * @see contextThisType
                 */
                function visitThisExpression(node) {
                    if (!contextThisType)
                        return ts.visitEachChild(node, visitor, context);
                    return createClosureCast(node, node, contextThisType);
                }
                /**
                 * visitVariableStatement flattens variable declaration lists (`var a, b;` to `var a; var
                 * b;`), and attaches JSDoc comments to each variable. JSDoc comments preceding the
                 * original variable are attached to the first newly created one.
                 */
                function visitVariableStatement(varStmt) {
                    const stmts = [];
                    // "const", "let", etc are stored in node flags on the declarationList.
                    const flags = ts.getCombinedNodeFlags(varStmt.declarationList);
                    let tags = moduleTypeTranslator.getJSDoc(varStmt, /* reportWarnings */ true);
                    const leading = ts.getSyntheticLeadingComments(varStmt);
                    if (leading) {
                        // Attach non-JSDoc comments to a not emitted statement.
                        const commentHolder = ts.createNotEmittedStatement(varStmt);
                        ts.setSyntheticLeadingComments(commentHolder, leading.filter(c => c.text[0] !== '*'));
                        stmts.push(commentHolder);
                    }
                    const declList = ts.visitNode(varStmt.declarationList, visitor);
                    for (const decl of declList.declarations) {
                        const localTags = [];
                        if (tags) {
                            // Add any tags and docs preceding the entire statement to the first variable.
                            localTags.push(...tags);
                            tags = null;
                        }
                        // Add an @type for plain identifiers, but not for bindings patterns (i.e. object or array
                        // destructuring - those do not have a syntax in Closure) or @defines, which already
                        // declare their type.
                        if (ts.isIdentifier(decl.name)) {
                            // For variables that are initialized and use a blacklisted type, do not emit a type at
                            // all. Closure Compiler might be able to infer a better type from the initializer than
                            // the `?` the code below would emit.
                            // TODO(martinprobst): consider doing this for all types that get emitted as ?, not just
                            // for blacklisted ones.
                            const blackListedInitialized = !!decl.initializer && moduleTypeTranslator.isBlackListed(decl);
                            if (!blackListedInitialized) {
                                // getOriginalNode(decl) is required because the type checker cannot type check
                                // synthesized nodes.
                                const typeStr = moduleTypeTranslator.typeToClosure(ts.getOriginalNode(decl));
                                // If @define is present then add the type to it, rather than adding a normal @type.
                                const defineTag = localTags.find(({ tagName }) => tagName === 'define');
                                if (defineTag) {
                                    defineTag.type = typeStr;
                                }
                                else {
                                    localTags.push({ tagName: 'type', type: typeStr });
                                }
                            }
                        }
                        const newStmt = ts.createVariableStatement(varStmt.modifiers, ts.createVariableDeclarationList([decl], flags));
                        if (localTags.length)
                            addCommentOn(newStmt, localTags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                        stmts.push(newStmt);
                    }
                    return stmts;
                }
                /**
                 * shouldEmitExportsAssignments returns true if tsickle should emit `exports.Foo = ...` style
                 * export statements.
                 *
                 * TypeScript modules can export types. Because types are pure design-time constructs in
                 * TypeScript, it does not emit any actual exported symbols for these. But tsickle has to emit
                 * an export, so that downstream Closure code (including tsickle-converted Closure code) can
                 * import upstream types. tsickle has to pick a module format for that, because the pure ES6
                 * export would get stripped by TypeScript.
                 *
                 * tsickle uses CommonJS to emit googmodule, and code not using googmodule doesn't care about
                 * the Closure annotations anyway, so tsickle skips emitting exports if the module target
                 * isn't commonjs.
                 */
                function shouldEmitExportsAssignments() {
                    return tsOptions.module === ts.ModuleKind.CommonJS;
                }
                function visitTypeAliasDeclaration(typeAlias) {
                    const sym = moduleTypeTranslator.mustGetSymbolAtLocation(typeAlias.name);
                    // If the type is also defined as a value, skip emitting it. Closure collapses type & value
                    // namespaces, the two emits would conflict if tsickle emitted both.
                    if (transformer_util_1.symbolIsValue(typeChecker, sym))
                        return [];
                    if (!shouldEmitExportsAssignments())
                        return [];
                    const typeName = typeAlias.name.getText();
                    // Blacklist any type parameters, Closure does not support type aliases with type
                    // parameters.
                    moduleTypeTranslator.newTypeTranslator(typeAlias).blacklistTypeParameters(moduleTypeTranslator.symbolsToAliasedNames, typeAlias.typeParameters);
                    const typeStr = host.untyped ? '?' : moduleTypeTranslator.typeToClosure(typeAlias, undefined);
                    // We want to emit a @typedef.  They are a bit weird because they are 'var' statements
                    // that have no value.
                    const tags = moduleTypeTranslator.getJSDoc(typeAlias, /* reportWarnings */ true);
                    tags.push({ tagName: 'typedef', type: typeStr });
                    const isExported = transformerUtil.hasModifierFlag(typeAlias, ts.ModifierFlags.Export);
                    let decl;
                    if (isExported) {
                        // Given: export type T = ...;
                        // We cannot emit `export var foo;` and let TS generate from there because TypeScript
                        // drops exports that are never assigned values, and Closure requires us to not assign
                        // values to typedef exports. Introducing a new local variable and exporting it can cause
                        // bugs due to name shadowing and confusing TypeScript's logic on what symbols and types
                        // vs values are exported. Mangling the name to avoid the conflicts would be reasonably
                        // clean, but would require a two pass emit to first find all type alias names, mangle
                        // them, and emit the use sites only later.
                        // So we produce: exports.T;
                        decl = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), ts.createIdentifier(typeName)));
                    }
                    else {
                        // Given: type T = ...;
                        // We produce: var T;
                        // Note: not const, because 'const Foo;' is illegal;
                        // not let, because we want hoisting behavior for types.
                        decl = ts.createVariableStatement(
                        /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(ts.createIdentifier(typeName))]));
                    }
                    decl = ts.setSourceMapRange(decl, typeAlias);
                    addCommentOn(decl, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                    return [decl];
                }
                /** Emits a parenthesized Closure cast: `(/** \@type ... * / (expr))`. */
                function createClosureCast(context, expression, type) {
                    const inner = ts.createParen(expression);
                    const comment = addCommentOn(inner, [{ tagName: 'type', type: moduleTypeTranslator.typeToClosure(context, type) }]);
                    comment.hasTrailingNewLine = false;
                    return ts.setSourceMapRange(ts.createParen(inner), context);
                }
                /** Converts a TypeScript type assertion into a Closure Cast. */
                function visitAssertionExpression(assertion) {
                    const type = typeChecker.getTypeAtLocation(assertion.type);
                    return createClosureCast(assertion, ts.visitEachChild(assertion, visitor, context), type);
                }
                /**
                 * Converts a TypeScript non-null assertion into a Closure Cast, by stripping |null and
                 * |undefined from a union type.
                 */
                function visitNonNullExpression(nonNull) {
                    const type = typeChecker.getTypeAtLocation(nonNull.expression);
                    const nonNullType = typeChecker.getNonNullableType(type);
                    return createClosureCast(nonNull, ts.visitEachChild(nonNull, visitor, context), nonNullType);
                }
                function visitImportDeclaration(importDecl) {
                    // For each import, insert a goog.requireType for the module, so that if TypeScript does not
                    // emit the module because it's only used in type positions, the JSDoc comments still
                    // reference a valid Closure level symbol.
                    // No need to requireType side effect imports.
                    if (!importDecl.importClause)
                        return importDecl;
                    const sym = typeChecker.getSymbolAtLocation(importDecl.moduleSpecifier);
                    // Scripts do not have a symbol, and neither do unused modules. Scripts can still be
                    // imported, either as side effect imports or with an empty import set ("{}"). TypeScript
                    // does not emit a runtime load for an import with an empty list of symbols, but the import
                    // forces any global declarations from the library to be visible, which is what users use
                    // this for. No symbols from the script need requireType, so just return.
                    // TODO(evmar): revisit this.  If TS needs to see the module import, it's likely Closure
                    // does too.
                    if (!sym)
                        return importDecl;
                    const importPath = googmodule.resolveModuleName({ options: tsOptions, moduleResolutionHost: host.moduleResolutionHost }, sourceFile.fileName, importDecl.moduleSpecifier.text);
                    moduleTypeTranslator.requireType(importPath, sym, 
                    /* default import? */ !!importDecl.importClause.name);
                    return importDecl;
                }
                /**
                 * Closure Compiler will fail when it finds incorrect JSDoc tags on nodes. This function
                 * parses and then re-serializes JSDoc comments, escaping or removing illegal tags.
                 */
                function escapeIllegalJSDoc(node) {
                    const mjsdoc = moduleTypeTranslator.getMutableJSDoc(node);
                    mjsdoc.updateComment();
                }
                /** Returns true if a value export should be emitted for the given symbol in export *. */
                function shouldEmitValueExportForSymbol(sym) {
                    if (sym.flags & ts.SymbolFlags.Alias) {
                        sym = typeChecker.getAliasedSymbol(sym);
                    }
                    if ((sym.flags & ts.SymbolFlags.Value) === 0) {
                        // Note: We create explicit exports of type symbols for closure in visitExportDeclaration.
                        return false;
                    }
                    if (!tsOptions.preserveConstEnums && sym.flags & ts.SymbolFlags.ConstEnum) {
                        return false;
                    }
                    return true;
                }
                /**
                 * visitExportDeclaration requireTypes exported modules and emits explicit exports for
                 * types (which normally do not get emitted by TypeScript).
                 */
                function visitExportDeclaration(exportDecl) {
                    const importedModuleSymbol = exportDecl.moduleSpecifier &&
                        typeChecker.getSymbolAtLocation(exportDecl.moduleSpecifier);
                    if (importedModuleSymbol) {
                        // requireType all explicitly imported modules, so that symbols can be referenced and
                        // type only modules are usable from type declarations.
                        moduleTypeTranslator.requireType(exportDecl.moduleSpecifier.text, importedModuleSymbol, 
                        /* default import? */ false);
                    }
                    const typesToExport = [];
                    if (!exportDecl.exportClause) {
                        // export * from '...'
                        // Resolve the * into all value symbols exported, and update the export declaration.
                        // Explicitly spelled out exports (i.e. the exports of the current module) take precedence
                        // over implicit ones from export *. Use the current module's exports to filter.
                        const currentModuleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
                        const currentModuleExports = currentModuleSymbol && currentModuleSymbol.exports;
                        if (!importedModuleSymbol) {
                            moduleTypeTranslator.error(exportDecl, `export * without module symbol`);
                            return exportDecl;
                        }
                        const exportedSymbols = typeChecker.getExportsOfModule(importedModuleSymbol);
                        const exportSpecifiers = [];
                        for (const sym of exportedSymbols) {
                            if (currentModuleExports && currentModuleExports.has(sym.escapedName))
                                continue;
                            // We might have already generated an export for the given symbol.
                            if (expandedStarImports.has(sym.name))
                                continue;
                            expandedStarImports.add(sym.name);
                            // Only create an export specifier for values that are exported. For types, the code
                            // below creates specific export statements that match Closure's expectations.
                            if (shouldEmitValueExportForSymbol(sym)) {
                                exportSpecifiers.push(ts.createExportSpecifier(undefined, sym.name));
                            }
                            else {
                                typesToExport.push([sym.name, sym]);
                            }
                        }
                        exportDecl = ts.updateExportDeclaration(exportDecl, exportDecl.decorators, exportDecl.modifiers, ts.createNamedExports(exportSpecifiers), exportDecl.moduleSpecifier);
                    }
                    else {
                        for (const exp of exportDecl.exportClause.elements) {
                            const exportedName = transformerUtil.getIdentifierText(exp.name);
                            typesToExport.push([exportedName, moduleTypeTranslator.mustGetSymbolAtLocation(exp.name)]);
                        }
                    }
                    // Do not emit typedef re-exports in untyped mode.
                    if (host.untyped)
                        return exportDecl;
                    const result = [exportDecl];
                    for (const [exportedName, sym] of typesToExport) {
                        let aliasedSymbol = sym;
                        if (sym.flags & ts.SymbolFlags.Alias) {
                            aliasedSymbol = typeChecker.getAliasedSymbol(sym);
                        }
                        const isTypeAlias = (aliasedSymbol.flags & ts.SymbolFlags.Value) === 0 &&
                            (aliasedSymbol.flags & (ts.SymbolFlags.TypeAlias | ts.SymbolFlags.Interface)) !== 0;
                        if (!isTypeAlias)
                            continue;
                        const typeName = moduleTypeTranslator.symbolsToAliasedNames.get(aliasedSymbol) || aliasedSymbol.name;
                        const stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), exportedName));
                        addCommentOn(stmt, [{ tagName: 'typedef', type: '!' + typeName }]);
                        ts.addSyntheticTrailingComment(stmt, ts.SyntaxKind.SingleLineCommentTrivia, ' re-export typedef', true);
                        result.push(stmt);
                    }
                    return result;
                }
                /**
                 * Returns the identifiers exported in a single exported statement - typically just one
                 * identifier (e.g. for `export function foo()`), but multiple for `export declare var a, b`.
                 */
                function getExportDeclarationNames(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.VariableStatement:
                            const varDecl = node;
                            return varDecl.declarationList.declarations.map((d) => getExportDeclarationNames(d)[0]);
                        case ts.SyntaxKind.VariableDeclaration:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.InterfaceDeclaration:
                        case ts.SyntaxKind.ClassDeclaration:
                        case ts.SyntaxKind.ModuleDeclaration:
                        case ts.SyntaxKind.EnumDeclaration:
                            const decl = node;
                            if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {
                                break;
                            }
                            return [decl.name];
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            const typeAlias = node;
                            return [typeAlias.name];
                        default:
                            break;
                    }
                    moduleTypeTranslator.error(node, `unsupported export declaration ${ts.SyntaxKind[node.kind]}: ${node.getText()}`);
                    return [];
                }
                /**
                 * Ambient declarations declare types for TypeScript's benefit, and will be removed by
                 * TypeScript during its emit phase. Downstream Closure code however might be importing
                 * symbols from this module, so tsickle must emit a Closure-compatible exports declaration.
                 */
                function visitExportedAmbient(node) {
                    if (host.untyped || !shouldEmitExportsAssignments())
                        return [node];
                    const declNames = getExportDeclarationNames(node);
                    const result = [node];
                    for (const decl of declNames) {
                        const sym = typeChecker.getSymbolAtLocation(decl);
                        // Non-value objects do not exist at runtime, so we cannot access the symbol (it only
                        // exists in externs). Export them as a typedef, which forwards to the type in externs.
                        // Note: TypeScript emits odd code for exported ambients (exports.x for variables, just x
                        // for everything else). That seems buggy, and in either case this code should not attempt
                        // to fix it.
                        // See also https://github.com/Microsoft/TypeScript/issues/8015.
                        if (!transformer_util_1.symbolIsValue(typeChecker, sym)) {
                            // Do not emit re-exports for ModuleDeclarations.
                            // Ambient ModuleDeclarations are always referenced as global symbols, so they don't
                            // need to be exported.
                            if (node.kind === ts.SyntaxKind.ModuleDeclaration)
                                continue;
                            const mangledName = annotator_host_1.moduleNameAsIdentifier(host, sourceFile.fileName);
                            const declName = transformerUtil.getIdentifierText(decl);
                            const stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), declName));
                            addCommentOn(stmt, [{ tagName: 'typedef', type: `!${mangledName}.${declName}` }]);
                            result.push(stmt);
                        }
                    }
                    return result;
                }
                function visitor(node) {
                    if (transformerUtil.isAmbient(node)) {
                        if (!transformerUtil.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                            return node;
                        }
                        return visitExportedAmbient(node);
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ImportDeclaration:
                            return visitImportDeclaration(node);
                        case ts.SyntaxKind.ExportDeclaration:
                            return visitExportDeclaration(node);
                        case ts.SyntaxKind.ClassDeclaration:
                            return visitClassDeclaration(node);
                        case ts.SyntaxKind.InterfaceDeclaration:
                            return visitInterfaceDeclaration(node);
                        case ts.SyntaxKind.HeritageClause:
                            return visitHeritageClause(node);
                        case ts.SyntaxKind.ArrowFunction:
                        case ts.SyntaxKind.FunctionExpression:
                            // Inserting a comment before an expression can trigger automatic semicolon insertion,
                            // e.g. if the function below is the expression in a `return` statement. Parenthesizing
                            // prevents ASI, as long as the opening paren remains on the same line (which it does).
                            return ts.createParen(visitFunctionLikeDeclaration(node));
                        case ts.SyntaxKind.Constructor:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.MethodDeclaration:
                        case ts.SyntaxKind.GetAccessor:
                        case ts.SyntaxKind.SetAccessor:
                            return visitFunctionLikeDeclaration(node);
                        case ts.SyntaxKind.ThisKeyword:
                            return visitThisExpression(node);
                        case ts.SyntaxKind.VariableStatement:
                            return visitVariableStatement(node);
                        case ts.SyntaxKind.PropertyDeclaration:
                        case ts.SyntaxKind.PropertyAssignment:
                            escapeIllegalJSDoc(node);
                            break;
                        case ts.SyntaxKind.Parameter:
                            // Parameter properties (e.g. `constructor(/** docs */ private foo: string)`) might have
                            // JSDoc comments, including JSDoc tags recognized by Closure Compiler. Prevent emitting
                            // any comments on them, so that Closure doesn't error on them.
                            // See test_files/parameter_properties.ts.
                            const paramDecl = node;
                            if (transformerUtil.hasModifierFlag(paramDecl, ts.ModifierFlags.ParameterPropertyModifier)) {
                                ts.setSyntheticLeadingComments(paramDecl, []);
                                jsdoc.suppressLeadingCommentsRecursively(paramDecl);
                            }
                            break;
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            return visitTypeAliasDeclaration(node);
                        case ts.SyntaxKind.AsExpression:
                        case ts.SyntaxKind.TypeAssertionExpression:
                            return visitAssertionExpression(node);
                        case ts.SyntaxKind.NonNullExpression:
                            return visitNonNullExpression(node);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                sourceFile = ts.visitEachChild(sourceFile, visitor, context);
                return moduleTypeTranslator.insertAdditionalImports(sourceFile);
            };
        };
    }
    exports.jsdocTransformer = jsdocTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNkb2NfdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvanNkb2NfdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7SUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBRUgsaUNBQWlDO0lBRWpDLCtEQUF1RTtJQUN2RSx1REFBbUQ7SUFDbkQscURBQTJDO0lBQzNDLDJDQUFpQztJQUNqQywrRUFBOEQ7SUFDOUQsZ0VBQXNEO0lBQ3RELG1FQUFpRDtJQUNqRCxpRUFBNkQ7SUFFN0QsU0FBUyxZQUFZLENBQUMsSUFBYSxFQUFFLElBQWlCLEVBQUUsZUFBNkI7UUFDbkYsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztRQUNsRSxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzVELFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkIsRUFBRSxDQUFDLDJCQUEyQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvQyxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBS0Qsd0VBQXdFO0lBQ3hFLFNBQWdCLHNCQUFzQixDQUFDLE9BQW9CLEVBQUUsSUFBdUI7UUFDbEYsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjO1lBQUUsT0FBTztRQUNqQyx3RkFBd0Y7UUFDeEYsT0FBTyxDQUFDLElBQUksQ0FBQztZQUNYLE9BQU8sRUFBRSxVQUFVO1lBQ25CLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxD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bGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGpzZG9jX3RyYW5zZm9ybWVyIGNvbnRhaW5zIHRoZSBsb2dpYyB0byBhZGQgSlNEb2MgY29tbWVudHMgdG8gVHlwZVNjcmlwdCBjb2RlLlxuICpcbiAqIE9uZSBvZiB0c2lja2xlJ3MgZmVhdHVyZXMgaXMgdG8gYWRkIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSBKU0RvYyBjb21tZW50cyBjb250YWluaW5nIHR5cGVcbiAqIGFubm90YXRpb25zLCBpbmhlcml0YW5jZSBpbmZvcm1hdGlvbiwgZXRjLiwgb250byBUeXBlU2NyaXB0IGNvZGUuIFRoaXMgYWxsb3dzIENsb3N1cmUgQ29tcGlsZXIgdG9cbiAqIG1ha2UgYmV0dGVyIG9wdGltaXphdGlvbiBkZWNpc2lvbnMgY29tcGFyZWQgdG8gYW4gdW50eXBlZCBjb2RlIGJhc2UuXG4gKlxuICogVGhlIGVudHJ5IHBvaW50IHRvIHRoZSBhbm5vdGF0aW9uIG9wZXJhdGlvbiBpcyBqc2RvY1RyYW5zZm9ybWVyIGJlbG93LiBJdCBhZGRzIHN5bnRoZXRpYyBjb21tZW50c1xuICogdG8gZXhpc3RpbmcgVHlwZVNjcmlwdCBjb25zdHJ1Y3RzLCBmb3IgZXhhbXBsZTpcbiAqICAgICBjb25zdCB4OiBudW1iZXIgPSAxO1xuICogTWlnaHQgZ2V0IHRyYW5zZm9ybWVkIHRvOlxuICogICAgIC8uLiBcXEB0eXBlIHtudW1iZXJ9IC4vXG4gKiAgICAgY29uc3QgeDogbnVtYmVyID0gMTtcbiAqIExhdGVyIFR5cGVTY3JpcHQgcGhhc2VzIHRoZW4gcmVtb3ZlIHRoZSB0eXBlIGFubm90YXRpb24sIGFuZCB0aGUgZmluYWwgZW1pdCBpcyBKYXZhU2NyaXB0IHRoYXRcbiAqIG9ubHkgY29udGFpbnMgdGhlIEpTRG9jIGNvbW1lbnQuXG4gKlxuICogVG8gaGFuZGxlIGNlcnRhaW4gY29uc3RydWN0cywgdGhpcyB0cmFuc2Zvcm1lciBhbHNvIHBlcmZvcm1zIEFTVCB0cmFuc2Zvcm1hdGlvbnMsIGUuZy4gYnkgYWRkaW5nXG4gKiBDb21tb25KUy1zdHlsZSBleHBvcnRzIGZvciB0eXBlIGNvbnN0cnVjdHMsIGV4cGFuZGluZyBgZXhwb3J0ICpgLCBwYXJlbnRoZXNpemluZyBjYXN0cywgZXRjLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0Fubm90YXRvckhvc3QsIG1vZHVsZU5hbWVBc0lkZW50aWZpZXJ9IGZyb20gJy4vYW5ub3RhdG9yX2hvc3QnO1xuaW1wb3J0IHtoYXNFeHBvcnRpbmdEZWNvcmF0b3J9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgKiBhcyBnb29nbW9kdWxlIGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7TW9kdWxlVHlwZVRyYW5zbGF0b3J9IGZyb20gJy4vbW9kdWxlX3R5cGVfdHJhbnNsYXRvcic7XG5pbXBvcnQgKiBhcyB0cmFuc2Zvcm1lclV0aWwgZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCB7c3ltYm9sSXNWYWx1ZX0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCB7aXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWV9IGZyb20gJy4vdHlwZV90cmFuc2xhdG9yJztcblxuZnVuY3Rpb24gYWRkQ29tbWVudE9uKG5vZGU6IHRzLk5vZGUsIHRhZ3M6IGpzZG9jLlRhZ1tdLCBlc2NhcGVFeHRyYVRhZ3M/OiBTZXQ8c3RyaW5nPikge1xuICBjb25zdCBjb21tZW50ID0ganNkb2MudG9TeW50aGVzaXplZENvbW1lbnQodGFncywgZXNjYXBlRXh0cmFUYWdzKTtcbiAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMobm9kZSkgfHwgW107XG4gIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhub2RlLCBjb21tZW50cyk7XG4gIHJldHVybiBjb21tZW50O1xufVxuXG50eXBlIEhhc1R5cGVQYXJhbWV0ZXJzID1cbiAgICB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbnx0cy5DbGFzc0xpa2VEZWNsYXJhdGlvbnx0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbnx0cy5TaWduYXR1cmVEZWNsYXJhdGlvbjtcblxuLyoqIEFkZHMgYW4gXFxAdGVtcGxhdGUgY2xhdXNlIHRvIGRvY1RhZ3MgaWYgZGVjbCBoYXMgdHlwZSBwYXJhbWV0ZXJzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQWRkVGVtcGxhdGVDbGF1c2UoZG9jVGFnczoganNkb2MuVGFnW10sIGRlY2w6IEhhc1R5cGVQYXJhbWV0ZXJzKSB7XG4gIGlmICghZGVjbC50eXBlUGFyYW1ldGVycykgcmV0dXJuO1xuICAvLyBDbG9zdXJlIGRvZXMgbm90IHN1cHBvcnQgdGVtcGxhdGUgY29uc3RyYWludHMgKFQgZXh0ZW5kcyBYKSwgdGhlc2UgYXJlIGlnbm9yZWQgYmVsb3cuXG4gIGRvY1RhZ3MucHVzaCh7XG4gICAgdGFnTmFtZTogJ3RlbXBsYXRlJyxcbiAgICB0ZXh0OiBkZWNsLnR5cGVQYXJhbWV0ZXJzLm1hcCh0cCA9PiB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQodHAubmFtZSkpLmpvaW4oJywgJylcbiAgfSk7XG59XG5cbi8qKlxuICogQWRkcyBoZXJpdGFnZSBjbGF1c2VzIChcXEBleHRlbmRzLCBcXEBpbXBsZW1lbnRzKSB0byB0aGUgZ2l2ZW4gZG9jVGFncyBmb3IgZGVjbC4gVXNlZCBieVxuICoganNkb2NfdHJhbnNmb3JtZXIgYW5kIGV4dGVybnMgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKFxuICAgIGRvY1RhZ3M6IGpzZG9jLlRhZ1tdLCBtdHQ6IE1vZHVsZVR5cGVUcmFuc2xhdG9yLFxuICAgIGRlY2w6IHRzLkNsYXNzTGlrZURlY2xhcmF0aW9ufHRzLkludGVyZmFjZURlY2xhcmF0aW9uKSB7XG4gIGlmICghZGVjbC5oZXJpdGFnZUNsYXVzZXMpIHJldHVybjtcbiAgY29uc3QgaXNDbGFzcyA9IGRlY2wua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uO1xuICBjb25zdCBoYXNFeHRlbmRzID0gZGVjbC5oZXJpdGFnZUNsYXVzZXMuc29tZShjID0+IGMudG9rZW4gPT09IHRzLlN5bnRheEtpbmQuRXh0ZW5kc0tleXdvcmQpO1xuICBmb3IgKGNvbnN0IGhlcml0YWdlIG9mIGRlY2wuaGVyaXRhZ2VDbGF1c2VzKSB7XG4gICAgY29uc3QgaXNFeHRlbmRzID0gaGVyaXRhZ2UudG9rZW4gPT09IHRzLlN5bnRheEtpbmQuRXh0ZW5kc0tleXdvcmQ7XG4gICAgaWYgKGlzQ2xhc3MgJiYgaXNFeHRlbmRzKSB7XG4gICAgICAvLyBJZiBhIGNsYXNzIGhhcyBhbiBcImV4dGVuZHNcIiwgdGhhdCBpcyBwcmVzZXJ2ZWQgaW4gdGhlIEVTNiBvdXRwdXRcbiAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGVtaXQgYW55IGFkZGl0aW9uYWwganNkb2MuXG4gICAgICAvL1xuICAgICAgLy8gSG93ZXZlciBmb3IgYW1iaWVudCBkZWNsYXJhdGlvbnMsIHdlIG9ubHkgZW1pdCBleHRlcm5zLCBhbmQgaW4gdGhvc2Ugd2UgZG8gbmVlZCB0b1xuICAgICAgLy8gYWRkIFwiQGV4dGVuZHMge0Zvb31cIiBhcyB0aGV5IHVzZSBFUzUgc3ludGF4LlxuICAgICAgaWYgKCF0cmFuc2Zvcm1lclV0aWwuaXNBbWJpZW50KGRlY2wpKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlIGdldCBoZXJlLCB3ZSBuZWVkIHRvIGVtaXQgc29tZSBqc2RvYy5cbiAgICBmb3IgKGNvbnN0IGV4cHIgb2YgaGVyaXRhZ2UudHlwZXMpIHtcbiAgICAgIGNvbnN0IGhlcml0YWdlID0gaGVyaXRhZ2VOYW1lKGlzRXh0ZW5kcywgaGFzRXh0ZW5kcywgZXhwcik7XG4gICAgICAvLyBoZXJpdGFnZU5hbWUgbWF5IHJldHVybiBudWxsLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGNsYXVzZSBpcyBzb21ldGhpbmcgaW5leHByZXNzaWJsZVxuICAgICAgLy8gaW4gQ2xvc3VyZSwgZS5nLiBcImNsYXNzIEZvbyBpbXBsZW1lbnRzIFBhcnRpYWw8QmFyPlwiLlxuICAgICAgaWYgKGhlcml0YWdlKSB7XG4gICAgICAgIGRvY1RhZ3MucHVzaCh7XG4gICAgICAgICAgdGFnTmFtZTogaGVyaXRhZ2UudGFnTmFtZSxcbiAgICAgICAgICB0eXBlOiBoZXJpdGFnZS5wYXJlbnROYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIENsb3N1cmUgbmFtZSBvZiBhbiBleHByZXNzaW9uIG9jY3VycmluZyBpbiBhIGhlcml0YWdlIGNsYXVzZSxcbiAgICogZS5nLiBcImltcGxlbWVudHMgRm9vQmFyXCIuICBXaWxsIHJldHVybiBudWxsIGlmIHRoZSBleHByZXNzaW9uIGlzIGluZXhwcmVzc2libGVcbiAgICogaW4gQ2xvc3VyZSBzZW1hbnRpY3MuICBOb3RlIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciBhbGwgcG9zc2libGVcbiAgICogY29tYmluYXRpb25zIG9mIHR5cGVzL3ZhbHVlcyBhbmQgZXh0ZW5kcy9pbXBsZW1lbnRzIGJlY2F1c2Ugb3VyIGlucHV0IGlzXG4gICAqIGFscmVhZHkgdmVyaWZpZWQgdG8gYmUgdmFsaWQgVHlwZVNjcmlwdC4gIFNlZSB0ZXN0X2ZpbGVzL2NsYXNzLyBmb3IgdGhlIGZ1bGxcbiAgICogY2FydGVzaWFuIHByb2R1Y3Qgb2YgdGVzdCBjYXNlcy5cbiAgICogQHBhcmFtIGlzRXh0ZW5kcyBUcnVlIGlmIHdlJ3JlIGluIGFuICdleHRlbmRzJywgZmFsc2UgaW4gYW4gJ2ltcGxlbWVudHMnLlxuICAgKiBAcGFyYW0gaGFzRXh0ZW5kcyBUcnVlIGlmIHRoZXJlIGFyZSBhbnkgJ2V4dGVuZHMnIGNsYXVzZXMgcHJlc2VudCBhdCBhbGwuXG4gICAqL1xuICBmdW5jdGlvbiBoZXJpdGFnZU5hbWUoXG4gICAgICBpc0V4dGVuZHM6IGJvb2xlYW4sIGhhc0V4dGVuZHM6IGJvb2xlYW4sXG4gICAgICBleHByOiB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMpOiB7dGFnTmFtZTogc3RyaW5nLCBwYXJlbnROYW1lOiBzdHJpbmd9fG51bGwge1xuICAgIGxldCB0YWdOYW1lID0gaXNFeHRlbmRzID8gJ2V4dGVuZHMnIDogJ2ltcGxlbWVudHMnO1xuICAgIGxldCBzeW0gPSBtdHQudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihleHByLmV4cHJlc3Npb24pO1xuICAgIGlmICghc3ltKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciBhIGNsYXNzIGRlY2xhcmF0aW9uIHRvIGV4dGVuZCBhbiBleHByZXNzaW9uIHRoYXRcbiAgICAgIC8vIGRvZXMgbm90IGhhdmUgaGF2ZSBhIHN5bWJvbCwgZm9yIGV4YW1wbGUgd2hlbiBhIG1peGluIGZ1bmN0aW9uIGlzXG4gICAgICAvLyB1c2VkIHRvIGJ1aWxkIGEgYmFzZSBjbGFzcywgYXMgaW4gYGRlY2xhcmUgTXlDbGFzcyBleHRlbmRzXG4gICAgICAvLyBNeU1peGluKE15QmFzZUNsYXNzKWAuXG4gICAgICAvL1xuICAgICAgLy8gSGFuZGxpbmcgdGhpcyBjb3JyZWN0bHkgaXMgdHJpY2t5LiBDbG9zdXJlIHRocm93cyBvbiB0aGlzXG4gICAgICAvLyBgZXh0ZW5kcyA8ZXhwcmVzc2lvbj5gIHN5bnRheCAoc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzIxODIpLiBXZSB3b3VsZFxuICAgICAgLy8gcHJvYmFibHkgbmVlZCB0byBnZW5lcmF0ZSBhbiBpbnRlcm1lZGlhdGUgY2xhc3MgZGVjbGFyYXRpb24gYW5kXG4gICAgICAvLyBleHRlbmQgdGhhdC5cbiAgICAgIG10dC5kZWJ1Z1dhcm4oZGVjbCwgYGNvdWxkIG5vdCByZXNvbHZlIHN1cGVydHlwZTogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc29sdmUgYW55IGFsaWFzZXMgdG8gdGhlIHVuZGVybHlpbmcgdHlwZS5cbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzKSB7XG4gICAgICAvLyBJdCdzIGltcGxlbWVudGluZyBhIHR5cGUgYWxpYXMuICBGb2xsb3cgdGhlIHR5cGUgYWxpYXMgYmFja1xuICAgICAgLy8gdG8gdGhlIG9yaWdpbmFsIHN5bWJvbCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSB0eXBlIG9yIGEgdmFsdWUuXG4gICAgICBjb25zdCB0eXBlID0gbXR0LnR5cGVDaGVja2VyLmdldERlY2xhcmVkVHlwZU9mU3ltYm9sKHN5bSk7XG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIC8vIEl0J3Mgbm90IGNsZWFyIHdoZW4gdGhpcyBjYW4gaGFwcGVuLlxuICAgICAgICBtdHQuZGVidWdXYXJuKGRlY2wsIGBjb3VsZCBub3QgZ2V0IHR5cGUgb2Ygc3ltYm9sOiAke2V4cHIuZ2V0VGV4dCgpfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN5bSA9IHR5cGUuc3ltYm9sO1xuICAgIH1cbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bSA9IG10dC50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZVRyYW5zbGF0b3IgPSBtdHQubmV3VHlwZVRyYW5zbGF0b3IoZXhwci5leHByZXNzaW9uKTtcbiAgICBpZiAodHlwZVRyYW5zbGF0b3IuaXNCbGFja0xpc3RlZChzeW0pKSB7XG4gICAgICAvLyBEb24ndCBlbWl0IHJlZmVyZW5jZXMgdG8gYmxhY2tsaXN0ZWQgdHlwZXMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ2xhc3MpIHtcbiAgICAgIGlmICghaXNDbGFzcykge1xuICAgICAgICAvLyBDbG9zdXJlIGludGVyZmFjZXMgY2Fubm90IGV4dGVuZCBvciBpbXBsZW1lbnRzIGNsYXNzZXMuXG4gICAgICAgIG10dC5kZWJ1Z1dhcm4oZGVjbCwgYG9taXR0aW5nIGludGVyZmFjZSBkZXJpdmluZyBmcm9tIGNsYXNzOiAke2V4cHIuZ2V0VGV4dCgpfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFeHRlbmRzKSB7XG4gICAgICAgIGlmICghaGFzRXh0ZW5kcykge1xuICAgICAgICAgIC8vIEEgc3BlY2lhbCBjYXNlOiBmb3IgYSBjbGFzcyB0aGF0IGhhcyBubyBleGlzdGluZyAnZXh0ZW5kcycgY2xhdXNlIGJ1dCBkb2VzXG4gICAgICAgICAgLy8gaGF2ZSBhbiAnaW1wbGVtZW50cycgY2xhdXNlIHRoYXQgcmVmZXJzIHRvIGFub3RoZXIgY2xhc3MsIHdlIGNoYW5nZSBpdCB0b1xuICAgICAgICAgIC8vIGluc3RlYWQgYmUgYW4gJ2V4dGVuZHMnLiAgVGhpcyB3YXMgYSBwb29ybHktdGhvdWdodC1vdXQgaGFjayB0aGF0IG1heVxuICAgICAgICAgIC8vIGFjdHVhbGx5IGNhdXNlIGNvbXBpbGVyIGJ1Z3M6XG4gICAgICAgICAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMxMjZcbiAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBjb2RlIHRoYXQgbm93IHJlbGllcyBvbiBpdCwgdWdoLlxuICAgICAgICAgIHRhZ05hbWUgPSAnZXh0ZW5kcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xvc3VyZSBjYW4gb25seSBAaW1wbGVtZW50cyBhbiBpbnRlcmZhY2UsIG5vdCBhIGNsYXNzLlxuICAgICAgICAgIG10dC5kZWJ1Z1dhcm4oZGVjbCwgYG9taXR0aW5nIEBpbXBsZW1lbnRzIG9mIGEgY2xhc3M6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSB7XG4gICAgICAvLyBJZiBpdCdzIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgY2xhc3MgaW4gdGhlIHZhbHVlIG5hbWVzcGFjZSwgdGhlbiBpdCB3aWxsXG4gICAgICAvLyBub3QgYmUgYSB0eXBlIGluIHRoZSBDbG9zdXJlIG91dHB1dCAoYmVjYXVzZSBDbG9zdXJlIGNvbGxhcHNlc1xuICAgICAgLy8gdGhlIHR5cGUgYW5kIHZhbHVlIG5hbWVzcGFjZXMpLlxuICAgICAgbXR0LmRlYnVnV2FybihcbiAgICAgICAgICBkZWNsLCBgb21pdHRpbmcgaGVyaXRhZ2UgcmVmZXJlbmNlIHRvIGEgdHlwZS92YWx1ZSBjb25mbGljdDogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZUxpdGVyYWwpIHtcbiAgICAgIC8vIEEgdHlwZSBsaXRlcmFsIGlzIGEgdHlwZSBsaWtlIGB7Zm9vOiBzdHJpbmd9YC5cbiAgICAgIC8vIFRoZXNlIGNhbiBjb21lIHVwIGFzIHRoZSBvdXRwdXQgb2YgYSBtYXBwZWQgdHlwZS5cbiAgICAgIG10dC5kZWJ1Z1dhcm4oZGVjbCwgYG9taXR0aW5nIGhlcml0YWdlIHJlZmVyZW5jZSB0byBhIHR5cGUgbGl0ZXJhbDogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHR5cGVUb0Nsb3N1cmUgaW5jbHVkZXMgbnVsbGFiaWxpdHkgbW9kaWZpZXJzLCBzbyBjYWxsIHN5bWJvbFRvU3RyaW5nIGRpcmVjdGx5IGhlcmUuXG4gICAgY29uc3QgcGFyZW50TmFtZSA9IHR5cGVUcmFuc2xhdG9yLnN5bWJvbFRvU3RyaW5nKHN5bSk7XG4gICAgaWYgKCFwYXJlbnROYW1lKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge3RhZ05hbWUsIHBhcmVudE5hbWV9O1xuICB9XG59XG5cbi8qKlxuICogY3JlYXRlTWVtYmVyVHlwZURlY2xhcmF0aW9uIGVtaXRzIHRoZSB0eXBlIGFubm90YXRpb25zIGZvciBtZW1iZXJzIG9mIGEgY2xhc3MuIEl0J3MgbmVjZXNzYXJ5IGluXG4gKiB0aGUgY2FzZSB3aGVyZSBUeXBlU2NyaXB0IHN5bnRheCBzcGVjaWZpZXMgdGhlcmUgYXJlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvbiB0aGUgY2xhc3MsIGJlY2F1c2VcbiAqIHRvIGRlY2xhcmUgdGhlc2UgaW4gQ2xvc3VyZSB5b3UgbXVzdCBkZWNsYXJlIHRoZXNlIHNlcGFyYXRlbHkgZnJvbSB0aGUgY2xhc3MuXG4gKlxuICogY3JlYXRlTWVtYmVyVHlwZURlY2xhcmF0aW9uIHByb2R1Y2VzIGFuIGlmIChmYWxzZSkgc3RhdGVtZW50IGNvbnRhaW5pbmcgcHJvcGVydHkgZGVjbGFyYXRpb25zLCBvclxuICogbnVsbCBpZiBubyBkZWNsYXJhdGlvbnMgY291bGQgb3IgbmVlZGVkIHRvIGJlIGdlbmVyYXRlZCAoZS5nLiBubyBtZW1iZXJzLCBvciBhbiB1bm5hbWVkIHR5cGUpLlxuICogVGhlIGlmIHN0YXRlbWVudCBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgY29kZSBpcyBub3QgZXhlY3V0ZWQsIG90aGVyd2lzZSBwcm9wZXJ0eSBhY2Nlc3NlcyBjb3VsZFxuICogdHJpZ2dlciBnZXR0ZXJzIG9uIGEgc3VwZXJjbGFzcy4gU2VlIHRlc3RfZmlsZXMvZmllbGRzL2ZpZWxkcy50czpCYXNlVGhhdFRocm93cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtYmVyVHlwZURlY2xhcmF0aW9uKFxuICAgIG10dDogTW9kdWxlVHlwZVRyYW5zbGF0b3IsXG4gICAgdHlwZURlY2w6IHRzLkNsYXNzRGVjbGFyYXRpb258dHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pOiB0cy5JZlN0YXRlbWVudHxudWxsIHtcbiAgLy8gR2F0aGVyIHBhcmFtZXRlciBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvbnN0cnVjdG9yLCBpZiBpdCBleGlzdHMuXG4gIGNvbnN0IGN0b3JzOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10gPSBbXTtcbiAgbGV0IHBhcmFtUHJvcHM6IHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uW10gPSBbXTtcbiAgY29uc3Qgbm9uU3RhdGljUHJvcHM6IEFycmF5PHRzLlByb3BlcnR5RGVjbGFyYXRpb258dHMuUHJvcGVydHlTaWduYXR1cmU+ID0gW107XG4gIGNvbnN0IHN0YXRpY1Byb3BzOiBBcnJheTx0cy5Qcm9wZXJ0eURlY2xhcmF0aW9ufHRzLlByb3BlcnR5U2lnbmF0dXJlPiA9IFtdO1xuICBjb25zdCB1bmhhbmRsZWQ6IHRzLk5hbWVkRGVjbGFyYXRpb25bXSA9IFtdO1xuICBjb25zdCBhYnN0cmFjdE1ldGhvZHM6IHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uW10gPSBbXTtcbiAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZURlY2wubWVtYmVycykge1xuICAgIGlmIChtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3Rvcikge1xuICAgICAgY3RvcnMucHVzaChtZW1iZXIgYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0cy5pc1Byb3BlcnR5RGVjbGFyYXRpb24obWVtYmVyKSB8fCB0cy5pc1Byb3BlcnR5U2lnbmF0dXJlKG1lbWJlcikpIHtcbiAgICAgIGNvbnN0IGlzU3RhdGljID0gdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhtZW1iZXIsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBzdGF0aWNQcm9wcy5wdXNoKG1lbWJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub25TdGF0aWNQcm9wcy5wdXNoKG1lbWJlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgbWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTWV0aG9kRGVjbGFyYXRpb24gfHxcbiAgICAgICAgbWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTWV0aG9kU2lnbmF0dXJlIHx8XG4gICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLkdldEFjY2Vzc29yIHx8IG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhtZW1iZXIsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpIHx8XG4gICAgICAgICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbih0eXBlRGVjbCkpIHtcbiAgICAgICAgYWJzdHJhY3RNZXRob2RzLnB1c2goXG4gICAgICAgICAgICBtZW1iZXIgYXMgdHMuTWV0aG9kRGVjbGFyYXRpb24gfCB0cy5HZXRBY2Nlc3NvckRlY2xhcmF0aW9uIHwgdHMuU2V0QWNjZXNzb3JEZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBOb24tYWJzdHJhY3QgbWV0aG9kcyBvbmx5IGV4aXN0IG9uIGNsYXNzZXMsIGFuZCBhcmUgaGFuZGxlZCBpbiByZWd1bGFyIGVtaXQuXG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaGFuZGxlZC5wdXNoKG1lbWJlcik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBPbmx5IHRoZSBhY3R1YWwgY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb24sIHdoaWNoIG11c3QgYmUgbGFzdCBpbiBhIHBvdGVudGlhbCBzZXF1ZW5jZSBvZlxuICAgIC8vIG92ZXJsb2FkZWQgY29uc3RydWN0b3JzLCBtYXkgY29udGFpbiBwYXJhbWV0ZXIgcHJvcGVydGllcy5cbiAgICBjb25zdCBjdG9yID0gY3RvcnNbY3RvcnMubGVuZ3RoIC0gMV07XG4gICAgcGFyYW1Qcm9wcyA9IGN0b3IucGFyYW1ldGVycy5maWx0ZXIoXG4gICAgICAgIHAgPT4gdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhwLCB0cy5Nb2RpZmllckZsYWdzLlBhcmFtZXRlclByb3BlcnR5TW9kaWZpZXIpKTtcbiAgfVxuXG4gIGlmIChub25TdGF0aWNQcm9wcy5sZW5ndGggPT09IDAgJiYgcGFyYW1Qcm9wcy5sZW5ndGggPT09IDAgJiYgc3RhdGljUHJvcHMubGVuZ3RoID09PSAwICYmXG4gICAgICBhYnN0cmFjdE1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIG1lbWJlcnMgc28gd2UgZG9uJ3QgbmVlZCB0byBlbWl0IGFueSB0eXBlXG4gICAgLy8gYW5ub3RhdGlvbnMgaGVscGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCF0eXBlRGVjbC5uYW1lKSB7XG4gICAgbXR0LmRlYnVnV2Fybih0eXBlRGVjbCwgJ2Nhbm5vdCBhZGQgdHlwZXMgb24gdW5uYW1lZCBkZWNsYXJhdGlvbnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGNsYXNzTmFtZSA9IHRyYW5zZm9ybWVyVXRpbC5nZXRJZGVudGlmaWVyVGV4dCh0eXBlRGVjbC5uYW1lKTtcbiAgY29uc3Qgc3RhdGljUHJvcEFjY2VzcyA9IHRzLmNyZWF0ZUlkZW50aWZpZXIoY2xhc3NOYW1lKTtcbiAgY29uc3QgaW5zdGFuY2VQcm9wQWNjZXNzID0gdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3Moc3RhdGljUHJvcEFjY2VzcywgJ3Byb3RvdHlwZScpO1xuICAvLyBDbG9zdXJlIENvbXBpbGVyIHdpbGwgcmVwb3J0IGNvbmZvcm1hbmNlIGVycm9ycyBhYm91dCB0aGlzIGJlaW5nIHVua25vd24gdHlwZSB3aGVuIGVtaXR0aW5nXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgYXMgez98dW5kZWZpbmVkfSwgaW5zdGVhZCBvZiBqdXN0IHs/fS4gU28gbWFrZSBzdXJlIHRvIG9ubHkgZW1pdCB7P3x1bmRlZmluZWR9XG4gIC8vIG9uIGludGVyZmFjZXMuXG4gIGNvbnN0IGlzSW50ZXJmYWNlID0gdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbih0eXBlRGVjbCk7XG4gIGNvbnN0IHByb3BlcnR5RGVjbHMgPSBzdGF0aWNQcm9wcy5tYXAoXG4gICAgICBwID0+IGNyZWF0ZUNsb3N1cmVQcm9wZXJ0eURlY2xhcmF0aW9uKFxuICAgICAgICAgIG10dCwgc3RhdGljUHJvcEFjY2VzcywgcCwgaXNJbnRlcmZhY2UgJiYgISFwLnF1ZXN0aW9uVG9rZW4pKTtcbiAgcHJvcGVydHlEZWNscy5wdXNoKC4uLlsuLi5ub25TdGF0aWNQcm9wcywgLi4ucGFyYW1Qcm9wc10ubWFwKFxuICAgICAgcCA9PiBjcmVhdGVDbG9zdXJlUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICAgICAgICBtdHQsIGluc3RhbmNlUHJvcEFjY2VzcywgcCwgaXNJbnRlcmZhY2UgJiYgISFwLnF1ZXN0aW9uVG9rZW4pKSk7XG4gIHByb3BlcnR5RGVjbHMucHVzaCguLi51bmhhbmRsZWQubWFwKFxuICAgICAgcCA9PiB0cmFuc2Zvcm1lclV0aWwuY3JlYXRlTXVsdGlMaW5lQ29tbWVudChcbiAgICAgICAgICBwLCBgU2tpcHBpbmcgdW5oYW5kbGVkIG1lbWJlcjogJHtlc2NhcGVGb3JDb21tZW50KHAuZ2V0VGV4dCgpKX1gKSkpO1xuXG4gIGZvciAoY29uc3QgZm5EZWNsIG9mIGFic3RyYWN0TWV0aG9kcykge1xuICAgIC8vIElmIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpcyBjb21wdXRlZCwgaXRzIG5hbWUgaXMgdGhlIGNvbXB1dGVkIGV4cHJlc3Npb247IG90aGVyd2lzZSwgaXRzXG4gICAgLy8gbmFtZSBjYW4gYmUgcmVzb2x2ZWQgdG8gYSBzdHJpbmcuXG4gICAgY29uc3QgbmFtZSA9IGZuRGVjbC5uYW1lICYmIHRzLmlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWUoZm5EZWNsLm5hbWUpID8gZm5EZWNsLm5hbWUuZXhwcmVzc2lvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lKGZuRGVjbCk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBtdHQuZXJyb3IoZm5EZWNsLCAnYW5vbnltb3VzIGFic3RyYWN0IGZ1bmN0aW9uJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qge3RhZ3MsIHBhcmFtZXRlck5hbWVzfSA9IG10dC5nZXRGdW5jdGlvblR5cGVKU0RvYyhbZm5EZWNsXSwgW10pO1xuICAgIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3IoZm5EZWNsLCBtdHQudHlwZUNoZWNrZXIpKSB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gICAgLy8gVXNlIGVsZW1lbnQgYWNjZXNzIGluc3RlYWQgb2YgcHJvcGVydHkgYWNjZXNzIGZvciBjb21wdWVkIG5hbWVzLlxuICAgIGNvbnN0IGxocyA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKGluc3RhbmNlUHJvcEFjY2VzcywgbmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUVsZW1lbnRBY2Nlc3MoaW5zdGFuY2VQcm9wQWNjZXNzLCBuYW1lKTtcbiAgICAvLyBtZW1iZXJOYW1lc3BhY2UgYmVjYXVzZSBhYnN0cmFjdCBtZXRob2RzIGNhbm5vdCBiZSBzdGF0aWMgaW4gVHlwZVNjcmlwdC5cbiAgICBjb25zdCBhYnN0cmFjdEZuRGVjbCA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVBc3NpZ25tZW50KFxuICAgICAgICBsaHMsXG4gICAgICAgIHRzLmNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihcbiAgICAgICAgICAgIC8qIG1vZGlmaWVycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAvKiBhc3RlcmlzayAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAvKiBuYW1lICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8qIHR5cGVQYXJhbWV0ZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWVzLm1hcChcbiAgICAgICAgICAgICAgICBuID0+IHRzLmNyZWF0ZVBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgICAgLyogZGVjb3JhdG9ycyAqLyB1bmRlZmluZWQsIC8qIG1vZGlmaWVycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIC8qIGRvdERvdERvdCAqLyB1bmRlZmluZWQsIG4pKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRzLmNyZWF0ZUJsb2NrKFtdKSxcbiAgICAgICAgICAgICkpKTtcbiAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMoYWJzdHJhY3RGbkRlY2wsIFtqc2RvYy50b1N5bnRoZXNpemVkQ29tbWVudCh0YWdzKV0pO1xuICAgIHByb3BlcnR5RGVjbHMucHVzaCh0cy5zZXRTb3VyY2VNYXBSYW5nZShhYnN0cmFjdEZuRGVjbCwgZm5EZWNsKSk7XG4gIH1cblxuICAvLyBTZWUgdGVzdF9maWxlcy9maWVsZHMvZmllbGRzLnRzOkJhc2VUaGF0VGhyb3dzIGZvciBhIG5vdGUgb24gdGhpcyB3cmFwcGVyLlxuICByZXR1cm4gdHMuY3JlYXRlSWYodHMuY3JlYXRlTGl0ZXJhbChmYWxzZSksIHRzLmNyZWF0ZUJsb2NrKHByb3BlcnR5RGVjbHMsIHRydWUpKTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlOYW1lKHByb3A6IHRzLk5hbWVkRGVjbGFyYXRpb24pOiBzdHJpbmd8bnVsbCB7XG4gIGlmICghcHJvcC5uYW1lKSByZXR1cm4gbnVsbDtcblxuICBzd2l0Y2ggKHByb3AubmFtZS5raW5kKSB7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICByZXR1cm4gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KHByb3AubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDpcbiAgICAgIC8vIEUuZy4gaW50ZXJmYWNlIEZvbyB7ICdiYXInOiBudW1iZXI7IH1cbiAgICAgIC8vIElmICdiYXInIGlzIGEgbmFtZSB0aGF0IGlzIG5vdCB2YWxpZCBpbiBDbG9zdXJlIHRoZW4gdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkby5cbiAgICAgIGNvbnN0IHRleHQgPSAocHJvcC5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICBpZiAoIWlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHRleHQpKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKiogUmVtb3ZlcyBjb21tZW50IG1ldGFjaGFyYWN0ZXJzIGZyb20gYSBzdHJpbmcsIHRvIG1ha2UgaXQgc2FmZSB0byBlbWJlZCBpbiBhIGNvbW1lbnQuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRm9yQ29tbWVudChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFwvXFwqL2csICdfXycpLnJlcGxhY2UoL1xcKlxcLy9nLCAnX18nKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xvc3VyZVByb3BlcnR5RGVjbGFyYXRpb24oXG4gICAgbXR0OiBNb2R1bGVUeXBlVHJhbnNsYXRvciwgZXhwcjogdHMuRXhwcmVzc2lvbixcbiAgICBwcm9wOiB0cy5Qcm9wZXJ0eURlY2xhcmF0aW9ufHRzLlByb3BlcnR5U2lnbmF0dXJlfHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uLFxuICAgIG9wdGlvbmFsOiBib29sZWFuKTogdHMuU3RhdGVtZW50IHtcbiAgY29uc3QgbmFtZSA9IHByb3BlcnR5TmFtZShwcm9wKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgbXR0LmRlYnVnV2Fybihwcm9wLCBgaGFuZGxlIHVubmFtZWQgbWVtYmVyOlxcbiR7ZXNjYXBlRm9yQ29tbWVudChwcm9wLmdldFRleHQoKSl9YCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyVXRpbC5jcmVhdGVNdWx0aUxpbmVDb21tZW50KFxuICAgICAgICBwcm9wLCBgU2tpcHBpbmcgdW5uYW1lZCBtZW1iZXI6XFxuJHtlc2NhcGVGb3JDb21tZW50KHByb3AuZ2V0VGV4dCgpKX1gKTtcbiAgfVxuXG4gIGxldCB0eXBlID0gbXR0LnR5cGVUb0Nsb3N1cmUocHJvcCk7XG4gIC8vIFdoZW4gYSBwcm9wZXJ0eSBpcyBvcHRpb25hbCwgZS5nLlxuICAvLyAgIGZvbz86IHN0cmluZztcbiAgLy8gVGhlbiB0aGUgVHlwZVNjcmlwdCB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpcyBzdHJpbmd8dW5kZWZpbmVkLCB0aGVcbiAgLy8gdHlwZVRvQ2xvc3VyZSB0cmFuc2xhdGlvbiBoYW5kbGVzIGl0IGNvcnJlY3RseSwgYW5kIHN0cmluZ3x1bmRlZmluZWQgaXNcbiAgLy8gaG93IHlvdSB3cml0ZSBhbiBvcHRpb25hbCBwcm9wZXJ0eSBpbiBDbG9zdXJlLlxuICAvL1xuICAvLyBCdXQgaW4gdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBvcHRpb25hbCBwcm9wZXJ0eSB3aXRoIHR5cGUgYW55OlxuICAvLyAgIGZvbz86IGFueTtcbiAgLy8gVGhlIFR5cGVTY3JpcHQgdHlwZSBvZiB0aGUgcHJvcGVydHkgaXMganVzdCBcImFueVwiIChiZWNhdXNlIGFueSBpbmNsdWRlc1xuICAvLyB1bmRlZmluZWQgYXMgd2VsbCkgc28gb3VyIGRlZmF1bHQgdHJhbnNsYXRpb24gb2YgdGhlIHR5cGUgaXMganVzdCBcIj9cIi5cbiAgLy8gVG8gbWFyayB0aGUgcHJvcGVydHkgYXMgb3B0aW9uYWwgaW4gQ2xvc3VyZSBpdCBtdXN0IGhhdmUgXCJ8dW5kZWZpbmVkXCIsXG4gIC8vIHNvIHRoZSBDbG9zdXJlIHR5cGUgbXVzdCBiZSA/fHVuZGVmaW5lZC5cbiAgaWYgKG9wdGlvbmFsICYmIHR5cGUgPT09ICc/JykgdHlwZSArPSAnfHVuZGVmaW5lZCc7XG5cbiAgY29uc3QgdGFncyA9IG10dC5nZXRKU0RvYyhwcm9wLCAvKiByZXBvcnRXYXJuaW5ncyAqLyB0cnVlKTtcbiAgdGFncy5wdXNoKHt0YWdOYW1lOiAndHlwZScsIHR5cGV9KTtcbiAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MocHJvcCk7XG4gIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUHJvdGVjdGVkKSB7XG4gICAgdGFncy5wdXNoKHt0YWdOYW1lOiAncHJvdGVjdGVkJ30pO1xuICB9IGVsc2UgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Qcml2YXRlKSB7XG4gICAgdGFncy5wdXNoKHt0YWdOYW1lOiAncHJpdmF0ZSd9KTtcbiAgfVxuICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKHByb3AsIG10dC50eXBlQ2hlY2tlcikpIHtcbiAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gIH1cbiAgY29uc3QgZGVjbFN0bXQgPVxuICAgICAgdHMuc2V0U291cmNlTWFwUmFuZ2UodHMuY3JlYXRlU3RhdGVtZW50KHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKGV4cHIsIG5hbWUpKSwgcHJvcCk7XG4gIC8vIEF2b2lkIHByaW50aW5nIGFubm90YXRpb25zIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggQHR5cGVcbiAgLy8gVGhpcyBhdm9pZHMgQ2xvc3VyZSdzIGVycm9yIFwidHlwZSBhbm5vdGF0aW9uIGluY29tcGF0aWJsZSB3aXRoIG90aGVyIGFubm90YXRpb25zXCJcbiAgYWRkQ29tbWVudE9uKGRlY2xTdG10LCB0YWdzLCBqc2RvYy5UQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSk7XG4gIHJldHVybiBkZWNsU3RtdDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFueSB0eXBlIGFzc2VydGlvbnMgYW5kIG5vbi1udWxsIGV4cHJlc3Npb25zIGZyb20gdGhlIEFTVCBiZWZvcmUgVHlwZVNjcmlwdCBwcm9jZXNzaW5nLlxuICpcbiAqIElkZWFsbHksIHRoZSBjb2RlIGluIGpzZG9jX3RyYW5zZm9ybWVyIGJlbG93IHNob3VsZCBqdXN0IHJlbW92ZSB0aGUgY2FzdCBleHByZXNzaW9uIGFuZFxuICogcmVwbGFjZSBpdCB3aXRoIHRoZSBDbG9zdXJlIGVxdWl2YWxlbnQuIEhvd2V2ZXIgQW5ndWxhcidzIGNvbXBpbGVyIGlzIGZyYWdpbGUgdG8gQVNUXG4gKiBub2RlcyBiZWluZyByZW1vdmVkIG9yIGNoYW5naW5nIHR5cGUsIHNvIHRoZSBjb2RlIG11c3QgcmV0YWluIHRoZSB0eXBlIGFzc2VydGlvblxuICogZXhwcmVzc2lvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNDg5NS5cbiAqXG4gKiB0c2lja2xlIGFsc28gY2Fubm90IGp1c3QgZ2VuZXJhdGUgYW5kIGtlZXAgYSBgKC8uLiBAdHlwZSB7U29tZVR5cGV9IC4vIChleHByIGFzIFNvbWVUeXBlKSlgXG4gKiBiZWNhdXNlIFR5cGVTY3JpcHQgcmVtb3ZlcyB0aGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBpbiB0aGF0IHN5bnRheCwgKHJlYXNvbmFibHkpIGJlbGlldmluZ1xuICogdGhleSB3ZXJlIG9ubHkgYWRkZWQgZm9yIHRoZSBUUyBjYXN0LlxuICpcbiAqIFRoZSBmaW5hbCB3b3JrYXJvdW5kIGlzIHRoZW4gdG8ga2VlcCB0aGUgVHlwZVNjcmlwdCB0eXBlIGFzc2VydGlvbnMsIGFuZCBoYXZlIGEgcG9zdC1Bbmd1bGFyXG4gKiBwcm9jZXNzaW5nIHN0ZXAgdGhhdCByZW1vdmVzIHRoZSBhc3NlcnRpb25zIGJlZm9yZSBUeXBlU2NyaXB0IHNlZXMgdGhlbS5cbiAqXG4gKiBUT0RPKG1hcnRpbnByb2JzdCk6IHJlbW92ZSBvbmNlIHRoZSBBbmd1bGFyIGlzc3VlIGlzIGZpeGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHlwZUFzc2VydGlvbnMoKTogdHMuVHJhbnNmb3JtZXJGYWN0b3J5PHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZTogdHMuTm9kZSk6IHRzLk5vZGUge1xuICAgICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXNFeHByZXNzaW9uOlxuICAgICAgICAgICAgcmV0dXJuIHRzLnZpc2l0Tm9kZSgobm9kZSBhcyB0cy5Bc3NlcnRpb25FeHByZXNzaW9uKS5leHByZXNzaW9uLCB2aXNpdG9yKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTm9uTnVsbEV4cHJlc3Npb246XG4gICAgICAgICAgICByZXR1cm4gdHMudmlzaXROb2RlKChub2RlIGFzIHRzLk5vbk51bGxFeHByZXNzaW9uKS5leHByZXNzaW9uLCB2aXNpdG9yKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaXRvcihzb3VyY2VGaWxlKSBhcyB0cy5Tb3VyY2VGaWxlO1xuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICoganNkb2NUcmFuc2Zvcm1lciByZXR1cm5zIGEgdHJhbnNmb3JtZXIgZmFjdG9yeSB0aGF0IGNvbnZlcnRzIFR5cGVTY3JpcHQgdHlwZXMgaW50byB0aGUgZXF1aXZhbGVudFxuICogSlNEb2MgYW5ub3RhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc2RvY1RyYW5zZm9ybWVyKFxuICAgIGhvc3Q6IEFubm90YXRvckhvc3QsIHRzT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSk6IChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+XG4gICAgdHMuVHJhbnNmb3JtZXI8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCk6IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+ID0+IHtcbiAgICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZVR5cGVUcmFuc2xhdG9yID0gbmV3IE1vZHVsZVR5cGVUcmFuc2xhdG9yKFxuICAgICAgICAgIHNvdXJjZUZpbGUsIHR5cGVDaGVja2VyLCBob3N0LCBkaWFnbm9zdGljcywgLyppc0ZvckV4dGVybnMqLyBmYWxzZSk7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzZXQgb2YgYWxsIG5hbWVzIGV4cG9ydGVkIGZyb20gYW4gZXhwb3J0ICogaW4gdGhlIGN1cnJlbnQgbW9kdWxlLiBVc2VkIHRvIHByZXZlbnRcbiAgICAgICAqIGVtaXR0aW5nIGR1cGxpY2F0ZWQgZXhwb3J0cy4gVGhlIGZpcnN0IGV4cG9ydCAqIHRha2VzIHByZWNlZGVuY2UgaW4gRVM2LlxuICAgICAgICovXG4gICAgICBjb25zdCBleHBhbmRlZFN0YXJJbXBvcnRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hpbGUgQ2xvc3VyZSBjb21waWxlciBzdXBwb3J0cyBwYXJhbWV0ZXJpemVkIHR5cGVzLCBpbmNsdWRpbmcgcGFyYW1ldGVyaXplZCBgdGhpc2Agb25cbiAgICAgICAqIG1ldGhvZHMsIGl0IGRvZXMgbm90IHN1cHBvcnQgY29uc3RyYWludHMgb24gdGhlbS4gVGhhdCBtZWFucyB0aGF0IGFuIGBcXEB0ZW1wbGF0ZWBkIHR5cGUgaXNcbiAgICAgICAqIGFsd2F5cyBjb25zaWRlcmVkIHRvIGJlIGB1bmtub3duYCB3aXRoaW4gdGhlIG1ldGhvZCwgaW5jbHVkaW5nIGBUSElTYC5cbiAgICAgICAqXG4gICAgICAgKiBUbyBoZWxwIENsb3N1cmUgQ29tcGlsZXIsIHdlIGtlZXAgdHJhY2sgb2YgYW55IHRlbXBsYXRlZCB0aGlzIHJldHVybiB0eXBlLCBhbmQgc3Vic3RpdHV0ZVxuICAgICAgICogZXhwbGljaXQgY2FzdHMgdG8gdGhlIHRlbXBsYXRlZCB0eXBlLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgYW4gaW5jb21wbGV0ZSBzb2x1dGlvbiBhbmQgd29ya3MgYXJvdW5kIGEgc3BlY2lmaWMgcHJvYmxlbSB3aXRoIHdhcm5pbmdzIG9uIHVua25vd25cbiAgICAgICAqIHRoaXMgYWNjZXNzZXMuIE1vcmUgZ2VuZXJhbGx5LCBDbG9zdXJlIGFsc28gY2Fubm90IGluZmVyIGNvbnN0cmFpbnRzIGZvciBhbnkgb3RoZXJcbiAgICAgICAqIHRlbXBsYXRlZCB0eXBlcywgYnV0IHRoYXQgbWlnaHQgcmVxdWlyZSBhIG1vcmUgZ2VuZXJhbCBzb2x1dGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICovXG4gICAgICBsZXQgY29udGV4dFRoaXNUeXBlOiB0cy5UeXBlfG51bGwgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiB2aXNpdENsYXNzRGVjbGFyYXRpb24oY2xhc3NEZWNsOiB0cy5DbGFzc0RlY2xhcmF0aW9uKTogdHMuU3RhdGVtZW50W10ge1xuICAgICAgICBjb25zdCBjb250ZXh0VGhpc1R5cGVCYWNrdXAgPSBjb250ZXh0VGhpc1R5cGU7XG5cbiAgICAgICAgY29uc3QgbWpzZG9jID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0TXV0YWJsZUpTRG9jKGNsYXNzRGVjbCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lclV0aWwuaGFzTW9kaWZpZXJGbGFnKGNsYXNzRGVjbCwgdHMuTW9kaWZpZXJGbGFncy5BYnN0cmFjdCkpIHtcbiAgICAgICAgICBtanNkb2MudGFncy5wdXNoKHt0YWdOYW1lOiAnYWJzdHJhY3QnfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKG1qc2RvYy50YWdzLCBjbGFzc0RlY2wpO1xuICAgICAgICBpZiAoIWhvc3QudW50eXBlZCkge1xuICAgICAgICAgIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKG1qc2RvYy50YWdzLCBtb2R1bGVUeXBlVHJhbnNsYXRvciwgY2xhc3NEZWNsKTtcbiAgICAgICAgfVxuICAgICAgICBtanNkb2MudXBkYXRlQ29tbWVudCgpO1xuICAgICAgICBjb25zdCBkZWNsczogdHMuU3RhdGVtZW50W10gPSBbXTtcbiAgICAgICAgY29uc3QgbWVtYmVyRGVjbCA9IGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbihtb2R1bGVUeXBlVHJhbnNsYXRvciwgY2xhc3NEZWNsKTtcbiAgICAgICAgLy8gV0FSTklORzogb3JkZXIgaXMgc2lnbmlmaWNhbnQ7IHdlIG11c3QgY3JlYXRlIHRoZSBtZW1iZXIgZGVjbCBiZWZvcmUgdHJhbnNmb3JtaW5nIGF3YXlcbiAgICAgICAgLy8gcGFyYW1ldGVyIHByb3BlcnR5IGNvbW1lbnRzIHdoZW4gdmlzaXRpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICBkZWNscy5wdXNoKHRzLnZpc2l0RWFjaENoaWxkKGNsYXNzRGVjbCwgdmlzaXRvciwgY29udGV4dCkpO1xuICAgICAgICBpZiAobWVtYmVyRGVjbCkgZGVjbHMucHVzaChtZW1iZXJEZWNsKTtcbiAgICAgICAgY29udGV4dFRoaXNUeXBlID0gY29udGV4dFRoaXNUeXBlQmFja3VwO1xuICAgICAgICByZXR1cm4gZGVjbHM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdmlzaXRIZXJpdGFnZUNsYXVzZSB3b3JrcyBhcm91bmQgYSBDbG9zdXJlIENvbXBpbGVyIGlzc3VlLCB3aGVyZSB0aGUgZXhwcmVzc2lvbiBpbiBhblxuICAgICAgICogXCJleHRlbmRzXCIgY2xhdXNlIG11c3QgYmUgYSBzaW1wbGUgaWRlbnRpZmllciwgYW5kIGluIHBhcnRpY3VsYXIgbXVzdCBub3QgYmUgYSBwYXJlbnRoZXNpemVkXG4gICAgICAgKiBleHByZXNzaW9uLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgdHJpZ2dlcmVkIHdoZW4gVFMgY29kZSB3cml0ZXMgXCJjbGFzcyBYIGV4dGVuZHMgKEZvbyBhcyBCYXIpIHsgLi4uIH1cIiwgY29tbW9ubHkgZG9uZVxuICAgICAgICogdG8gc3VwcG9ydCBtaXhpbnMuIEZvciBleHRlbmRzIGNsYXVzZXMgaW4gY2xhc3NlcywgdGhlIGNvZGUgYmVsb3cgZHJvcHMgdGhlIGNhc3QgYW5kIGFueVxuICAgICAgICogcGFyZW50aGV0aWNhbHMsIGxlYXZpbmcganVzdCB0aGUgb3JpZ2luYWwgZXhwcmVzc2lvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGFuIGluY29tcGxldGUgd29ya2Fyb3VuZCwgYXMgQ2xvc3VyZSB3aWxsIHN0aWxsIGJhaWwgb24gb3RoZXIgc3VwZXIgZXhwcmVzc2lvbnMsXG4gICAgICAgKiBidXQgcmV0YWlucyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHByZXZpb3VzIGVtaXQgdGhhdCAoYWNjaWRlbnRhbGx5KSBkcm9wcGVkIHRoZSBjYXN0XG4gICAgICAgKiBleHByZXNzaW9uLlxuICAgICAgICpcbiAgICAgICAqIFRPRE8obWFydGlucHJvYnN0KTogcmVtb3ZlIHRoaXMgb25jZSB0aGUgQ2xvc3VyZSBzaWRlIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdEhlcml0YWdlQ2xhdXNlKGhlcml0YWdlQ2xhdXNlOiB0cy5IZXJpdGFnZUNsYXVzZSkge1xuICAgICAgICBpZiAoaGVyaXRhZ2VDbGF1c2UudG9rZW4gIT09IHRzLlN5bnRheEtpbmQuRXh0ZW5kc0tleXdvcmQgfHwgIWhlcml0YWdlQ2xhdXNlLnBhcmVudCB8fFxuICAgICAgICAgICAgaGVyaXRhZ2VDbGF1c2UucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQoaGVyaXRhZ2VDbGF1c2UsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJpdGFnZUNsYXVzZS50eXBlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5lcnJvcihcbiAgICAgICAgICAgICAgaGVyaXRhZ2VDbGF1c2UsIGBleHBlY3RlZCBleGFjdGx5IG9uZSB0eXBlIGluIGNsYXNzIGV4dGVuc2lvbiBjbGF1c2VgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gaGVyaXRhZ2VDbGF1c2UudHlwZXNbMF07XG4gICAgICAgIGxldCBleHByOiB0cy5FeHByZXNzaW9uID0gdHlwZS5leHByZXNzaW9uO1xuICAgICAgICB3aGlsZSAodHMuaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihleHByKSB8fCB0cy5pc05vbk51bGxFeHByZXNzaW9uKGV4cHIpIHx8XG4gICAgICAgICAgICAgICB0cy5pc0Fzc2VydGlvbkV4cHJlc3Npb24oZXhwcikpIHtcbiAgICAgICAgICBleHByID0gZXhwci5leHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cy51cGRhdGVIZXJpdGFnZUNsYXVzZShoZXJpdGFnZUNsYXVzZSwgW3RzLnVwZGF0ZUV4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSwgdHlwZS50eXBlQXJndW1lbnRzIHx8IFtdLCBleHByKV0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2aXNpdEludGVyZmFjZURlY2xhcmF0aW9uKGlmYWNlOiB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbik6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihpZmFjZS5uYW1lKTtcbiAgICAgICAgaWYgKCFzeW0pIHtcbiAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5lcnJvcihpZmFjZSwgJ2ludGVyZmFjZSB3aXRoIG5vIHN5bWJvbCcpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHN5bWJvbCBpcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgd2UgY2Fubm90IGVtaXQgYm90aCBpbnRvIENsb3N1cmUnc1xuICAgICAgICAvLyBzaW5nbGUgbmFtZXNwYWNlLlxuICAgICAgICBpZiAoc3ltYm9sSXNWYWx1ZSh0eXBlQ2hlY2tlciwgc3ltKSkge1xuICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmRlYnVnV2FybihcbiAgICAgICAgICAgICAgaWZhY2UsIGB0eXBlL3N5bWJvbCBjb25mbGljdCBmb3IgJHtzeW0ubmFtZX0sIHVzaW5nIHs/fSBmb3Igbm93YCk7XG4gICAgICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lclV0aWwuY3JlYXRlU2luZ2xlTGluZUNvbW1lbnQoXG4gICAgICAgICAgICAgIGlmYWNlLCAnV0FSTklORzogaW50ZXJmYWNlIGhhcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgc2tpcHBpbmcgZW1pdCcpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhZ3MgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci5nZXRKU0RvYyhpZmFjZSwgLyogcmVwb3J0V2FybmluZ3MgKi8gdHJ1ZSkgfHwgW107XG4gICAgICAgIHRhZ3MucHVzaCh7dGFnTmFtZTogJ3JlY29yZCd9KTtcbiAgICAgICAgbWF5YmVBZGRUZW1wbGF0ZUNsYXVzZSh0YWdzLCBpZmFjZSk7XG4gICAgICAgIGlmICghaG9zdC51bnR5cGVkKSB7XG4gICAgICAgICAgbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXModGFncywgbW9kdWxlVHlwZVRyYW5zbGF0b3IsIGlmYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KGlmYWNlLm5hbWUpO1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSB0cmFuc2Zvcm1lclV0aWwuaGFzTW9kaWZpZXJGbGFnKGlmYWNlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkgP1xuICAgICAgICAgICAgW3RzLmNyZWF0ZVRva2VuKHRzLlN5bnRheEtpbmQuRXhwb3J0S2V5d29yZCldIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZGVjbCA9IHRzLnNldFNvdXJjZU1hcFJhbmdlKFxuICAgICAgICAgICAgdHMuY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICAvKiBkZWNvcmF0b3JzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgLyogYXN0ZXJpc2sgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgLyogdHlwZVBhcmFtZXRlcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8qIHBhcmFtZXRlcnMgKi9bXSxcbiAgICAgICAgICAgICAgICAvKiB0eXBlICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvKiBib2R5ICovIHRzLmNyZWF0ZUJsb2NrKFtdKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgaWZhY2UpO1xuICAgICAgICBhZGRDb21tZW50T24oZGVjbCwgdGFncyk7XG4gICAgICAgIGNvbnN0IG1lbWJlckRlY2wgPSBjcmVhdGVNZW1iZXJUeXBlRGVjbGFyYXRpb24obW9kdWxlVHlwZVRyYW5zbGF0b3IsIGlmYWNlKTtcbiAgICAgICAgcmV0dXJuIG1lbWJlckRlY2wgPyBbZGVjbCwgbWVtYmVyRGVjbF0gOiBbZGVjbF07XG4gICAgICB9XG5cbiAgICAgIC8qKiBGdW5jdGlvbiBkZWNsYXJhdGlvbnMgYXJlIGVtaXR0ZWQgYXMgdGhleSBhcmUsIHdpdGggb25seSBKU0RvYyBhZGRlZC4gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0RnVuY3Rpb25MaWtlRGVjbGFyYXRpb248VCBleHRlbmRzIHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uPihmbkRlY2w6IFQpOiBUIHtcbiAgICAgICAgaWYgKCFmbkRlY2wuYm9keSkge1xuICAgICAgICAgIC8vIFR3byBjYXNlczogYWJzdHJhY3QgbWV0aG9kcyBhbmQgb3ZlcmxvYWRlZCBtZXRob2RzL2Z1bmN0aW9ucy5cbiAgICAgICAgICAvLyBBYnN0cmFjdCBtZXRob2RzIGFyZSBoYW5kbGVkIGluIGVtaXRUeXBlQW5ub3RhdGlvbnNIYW5kbGVyLlxuICAgICAgICAgIC8vIE92ZXJsb2FkcyBhcmUgdW5pb24taXplZCBpbnRvIHRoZSBzaGFyZWQgdHlwZSBpbiBGdW5jdGlvblR5cGUuXG4gICAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKGZuRGVjbCwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0cmFUYWdzID0gW107XG4gICAgICAgIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3IoZm5EZWNsLCB0eXBlQ2hlY2tlcikpIGV4dHJhVGFncy5wdXNoKHt0YWdOYW1lOiAnZXhwb3J0J30pO1xuXG4gICAgICAgIGNvbnN0IHt0YWdzLCB0aGlzUmV0dXJuVHlwZX0gPVxuICAgICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoW2ZuRGVjbF0sIGV4dHJhVGFncyk7XG4gICAgICAgIGNvbnN0IG1qc2RvYyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldE11dGFibGVKU0RvYyhmbkRlY2wpO1xuICAgICAgICBtanNkb2MudGFncyA9IHRhZ3M7XG4gICAgICAgIG1qc2RvYy51cGRhdGVDb21tZW50KCk7XG5cbiAgICAgICAgY29uc3QgY29udGV4dFRoaXNUeXBlQmFja3VwID0gY29udGV4dFRoaXNUeXBlO1xuICAgICAgICAvLyBBcnJvdyBmdW5jdGlvbnMgcmV0YWluIHRoZWlyIGNvbnRleHQgYHRoaXNgIHR5cGUuIEFsbCBvdGhlcnMgcmVzZXQgdGhlIHRoaXMgdHlwZSB0b1xuICAgICAgICAvLyBlaXRoZXIgbm9uZSAoaWYgbm90IHNwZWNpZmllZCkgb3IgdGhlIHR5cGUgZ2l2ZW4gaW4gYSBmbih0aGlzOiBULCAuLi4pIGRlY2xhcmF0aW9uLlxuICAgICAgICBpZiAoIXRzLmlzQXJyb3dGdW5jdGlvbihmbkRlY2wpKSBjb250ZXh0VGhpc1R5cGUgPSB0aGlzUmV0dXJuVHlwZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHMudmlzaXRFYWNoQ2hpbGQoZm5EZWNsLCB2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dFRoaXNUeXBlID0gY29udGV4dFRoaXNUeXBlQmFja3VwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluIG1ldGhvZHMgd2l0aCBhIHRlbXBsYXRlZCB0aGlzIHR5cGUsIGFkZHMgZXhwbGljaXQgY2FzdHMgdG8gYWNjZXNzZXMgb24gdGhpcy5cbiAgICAgICAqXG4gICAgICAgKiBAc2VlIGNvbnRleHRUaGlzVHlwZVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdFRoaXNFeHByZXNzaW9uKG5vZGU6IHRzLlRoaXNFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmICghY29udGV4dFRoaXNUeXBlKSByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbG9zdXJlQ2FzdChub2RlLCBub2RlLCBjb250ZXh0VGhpc1R5cGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0VmFyaWFibGVTdGF0ZW1lbnQgZmxhdHRlbnMgdmFyaWFibGUgZGVjbGFyYXRpb24gbGlzdHMgKGB2YXIgYSwgYjtgIHRvIGB2YXIgYTsgdmFyXG4gICAgICAgKiBiO2ApLCBhbmQgYXR0YWNoZXMgSlNEb2MgY29tbWVudHMgdG8gZWFjaCB2YXJpYWJsZS4gSlNEb2MgY29tbWVudHMgcHJlY2VkaW5nIHRoZVxuICAgICAgICogb3JpZ2luYWwgdmFyaWFibGUgYXJlIGF0dGFjaGVkIHRvIHRoZSBmaXJzdCBuZXdseSBjcmVhdGVkIG9uZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRWYXJpYWJsZVN0YXRlbWVudCh2YXJTdG10OiB0cy5WYXJpYWJsZVN0YXRlbWVudCk6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3Qgc3RtdHM6IHRzLlN0YXRlbWVudFtdID0gW107XG5cbiAgICAgICAgLy8gXCJjb25zdFwiLCBcImxldFwiLCBldGMgYXJlIHN0b3JlZCBpbiBub2RlIGZsYWdzIG9uIHRoZSBkZWNsYXJhdGlvbkxpc3QuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gdHMuZ2V0Q29tYmluZWROb2RlRmxhZ3ModmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QpO1xuXG4gICAgICAgIGxldCB0YWdzOiBqc2RvYy5UYWdbXXxudWxsID1cbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldEpTRG9jKHZhclN0bXQsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgICAgICBjb25zdCBsZWFkaW5nID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHZhclN0bXQpO1xuICAgICAgICBpZiAobGVhZGluZykge1xuICAgICAgICAgIC8vIEF0dGFjaCBub24tSlNEb2MgY29tbWVudHMgdG8gYSBub3QgZW1pdHRlZCBzdGF0ZW1lbnQuXG4gICAgICAgICAgY29uc3QgY29tbWVudEhvbGRlciA9IHRzLmNyZWF0ZU5vdEVtaXR0ZWRTdGF0ZW1lbnQodmFyU3RtdCk7XG4gICAgICAgICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKGNvbW1lbnRIb2xkZXIsIGxlYWRpbmcuZmlsdGVyKGMgPT4gYy50ZXh0WzBdICE9PSAnKicpKTtcbiAgICAgICAgICBzdG10cy5wdXNoKGNvbW1lbnRIb2xkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVjbExpc3QgPSB0cy52aXNpdE5vZGUodmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QsIHZpc2l0b3IpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbExpc3QuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgICAgIGlmICh0YWdzKSB7XG4gICAgICAgICAgICAvLyBBZGQgYW55IHRhZ3MgYW5kIGRvY3MgcHJlY2VkaW5nIHRoZSBlbnRpcmUgc3RhdGVtZW50IHRvIHRoZSBmaXJzdCB2YXJpYWJsZS5cbiAgICAgICAgICAgIGxvY2FsVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICAgICAgdGFncyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCBhbiBAdHlwZSBmb3IgcGxhaW4gaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGJpbmRpbmdzIHBhdHRlcm5zIChpLmUuIG9iamVjdCBvciBhcnJheVxuICAgICAgICAgIC8vIGRlc3RydWN0dXJpbmcgLSB0aG9zZSBkbyBub3QgaGF2ZSBhIHN5bnRheCBpbiBDbG9zdXJlKSBvciBAZGVmaW5lcywgd2hpY2ggYWxyZWFkeVxuICAgICAgICAgIC8vIGRlY2xhcmUgdGhlaXIgdHlwZS5cbiAgICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGRlY2wubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEZvciB2YXJpYWJsZXMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgYW5kIHVzZSBhIGJsYWNrbGlzdGVkIHR5cGUsIGRvIG5vdCBlbWl0IGEgdHlwZSBhdFxuICAgICAgICAgICAgLy8gYWxsLiBDbG9zdXJlIENvbXBpbGVyIG1pZ2h0IGJlIGFibGUgdG8gaW5mZXIgYSBiZXR0ZXIgdHlwZSBmcm9tIHRoZSBpbml0aWFsaXplciB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgYD9gIHRoZSBjb2RlIGJlbG93IHdvdWxkIGVtaXQuXG4gICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IGNvbnNpZGVyIGRvaW5nIHRoaXMgZm9yIGFsbCB0eXBlcyB0aGF0IGdldCBlbWl0dGVkIGFzID8sIG5vdCBqdXN0XG4gICAgICAgICAgICAvLyBmb3IgYmxhY2tsaXN0ZWQgb25lcy5cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrTGlzdGVkSW5pdGlhbGl6ZWQgPVxuICAgICAgICAgICAgICAgICEhZGVjbC5pbml0aWFsaXplciAmJiBtb2R1bGVUeXBlVHJhbnNsYXRvci5pc0JsYWNrTGlzdGVkKGRlY2wpO1xuICAgICAgICAgICAgaWYgKCFibGFja0xpc3RlZEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIC8vIGdldE9yaWdpbmFsTm9kZShkZWNsKSBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSB0eXBlIGNoZWNrZXIgY2Fubm90IHR5cGUgY2hlY2tcbiAgICAgICAgICAgICAgLy8gc3ludGhlc2l6ZWQgbm9kZXMuXG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci50eXBlVG9DbG9zdXJlKHRzLmdldE9yaWdpbmFsTm9kZShkZWNsKSk7XG4gICAgICAgICAgICAgIC8vIElmIEBkZWZpbmUgaXMgcHJlc2VudCB0aGVuIGFkZCB0aGUgdHlwZSB0byBpdCwgcmF0aGVyIHRoYW4gYWRkaW5nIGEgbm9ybWFsIEB0eXBlLlxuICAgICAgICAgICAgICBjb25zdCBkZWZpbmVUYWcgPSBsb2NhbFRhZ3MuZmluZCgoe3RhZ05hbWV9KSA9PiB0YWdOYW1lID09PSAnZGVmaW5lJyk7XG4gICAgICAgICAgICAgIGlmIChkZWZpbmVUYWcpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVUYWcudHlwZSA9IHR5cGVTdHI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxUYWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogdHlwZVN0cn0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1N0bXQgPSB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgdmFyU3RtdC5tb2RpZmllcnMsIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFtkZWNsXSwgZmxhZ3MpKTtcbiAgICAgICAgICBpZiAobG9jYWxUYWdzLmxlbmd0aCkgYWRkQ29tbWVudE9uKG5ld1N0bXQsIGxvY2FsVGFncywganNkb2MuVEFHU19DT05GTElDVElOR19XSVRIX1RZUEUpO1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3U3RtdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RtdHM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2hvdWxkRW1pdEV4cG9ydHNBc3NpZ25tZW50cyByZXR1cm5zIHRydWUgaWYgdHNpY2tsZSBzaG91bGQgZW1pdCBgZXhwb3J0cy5Gb28gPSAuLi5gIHN0eWxlXG4gICAgICAgKiBleHBvcnQgc3RhdGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBUeXBlU2NyaXB0IG1vZHVsZXMgY2FuIGV4cG9ydCB0eXBlcy4gQmVjYXVzZSB0eXBlcyBhcmUgcHVyZSBkZXNpZ24tdGltZSBjb25zdHJ1Y3RzIGluXG4gICAgICAgKiBUeXBlU2NyaXB0LCBpdCBkb2VzIG5vdCBlbWl0IGFueSBhY3R1YWwgZXhwb3J0ZWQgc3ltYm9scyBmb3IgdGhlc2UuIEJ1dCB0c2lja2xlIGhhcyB0byBlbWl0XG4gICAgICAgKiBhbiBleHBvcnQsIHNvIHRoYXQgZG93bnN0cmVhbSBDbG9zdXJlIGNvZGUgKGluY2x1ZGluZyB0c2lja2xlLWNvbnZlcnRlZCBDbG9zdXJlIGNvZGUpIGNhblxuICAgICAgICogaW1wb3J0IHVwc3RyZWFtIHR5cGVzLiB0c2lja2xlIGhhcyB0byBwaWNrIGEgbW9kdWxlIGZvcm1hdCBmb3IgdGhhdCwgYmVjYXVzZSB0aGUgcHVyZSBFUzZcbiAgICAgICAqIGV4cG9ydCB3b3VsZCBnZXQgc3RyaXBwZWQgYnkgVHlwZVNjcmlwdC5cbiAgICAgICAqXG4gICAgICAgKiB0c2lja2xlIHVzZXMgQ29tbW9uSlMgdG8gZW1pdCBnb29nbW9kdWxlLCBhbmQgY29kZSBub3QgdXNpbmcgZ29vZ21vZHVsZSBkb2Vzbid0IGNhcmUgYWJvdXRcbiAgICAgICAqIHRoZSBDbG9zdXJlIGFubm90YXRpb25zIGFueXdheSwgc28gdHNpY2tsZSBza2lwcyBlbWl0dGluZyBleHBvcnRzIGlmIHRoZSBtb2R1bGUgdGFyZ2V0XG4gICAgICAgKiBpc24ndCBjb21tb25qcy5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2hvdWxkRW1pdEV4cG9ydHNBc3NpZ25tZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRzT3B0aW9ucy5tb2R1bGUgPT09IHRzLk1vZHVsZUtpbmQuQ29tbW9uSlM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZpc2l0VHlwZUFsaWFzRGVjbGFyYXRpb24odHlwZUFsaWFzOiB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbik6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3Qgc3ltID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IubXVzdEdldFN5bWJvbEF0TG9jYXRpb24odHlwZUFsaWFzLm5hbWUpO1xuICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyBhbHNvIGRlZmluZWQgYXMgYSB2YWx1ZSwgc2tpcCBlbWl0dGluZyBpdC4gQ2xvc3VyZSBjb2xsYXBzZXMgdHlwZSAmIHZhbHVlXG4gICAgICAgIC8vIG5hbWVzcGFjZXMsIHRoZSB0d28gZW1pdHMgd291bGQgY29uZmxpY3QgaWYgdHNpY2tsZSBlbWl0dGVkIGJvdGguXG4gICAgICAgIGlmIChzeW1ib2xJc1ZhbHVlKHR5cGVDaGVja2VyLCBzeW0pKSByZXR1cm4gW107XG4gICAgICAgIGlmICghc2hvdWxkRW1pdEV4cG9ydHNBc3NpZ25tZW50cygpKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0eXBlQWxpYXMubmFtZS5nZXRUZXh0KCk7XG5cbiAgICAgICAgLy8gQmxhY2tsaXN0IGFueSB0eXBlIHBhcmFtZXRlcnMsIENsb3N1cmUgZG9lcyBub3Qgc3VwcG9ydCB0eXBlIGFsaWFzZXMgd2l0aCB0eXBlXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLm5ld1R5cGVUcmFuc2xhdG9yKHR5cGVBbGlhcykuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnMoXG4gICAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIHR5cGVBbGlhcy50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgaG9zdC51bnR5cGVkID8gJz8nIDogbW9kdWxlVHlwZVRyYW5zbGF0b3IudHlwZVRvQ2xvc3VyZSh0eXBlQWxpYXMsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBlbWl0IGEgQHR5cGVkZWYuICBUaGV5IGFyZSBhIGJpdCB3ZWlyZCBiZWNhdXNlIHRoZXkgYXJlICd2YXInIHN0YXRlbWVudHNcbiAgICAgICAgLy8gdGhhdCBoYXZlIG5vIHZhbHVlLlxuICAgICAgICBjb25zdCB0YWdzID0gbW9kdWxlVHlwZVRyYW5zbGF0b3IuZ2V0SlNEb2ModHlwZUFsaWFzLCAvKiByZXBvcnRXYXJuaW5ncyAqLyB0cnVlKTtcbiAgICAgICAgdGFncy5wdXNoKHt0YWdOYW1lOiAndHlwZWRlZicsIHR5cGU6IHR5cGVTdHJ9KTtcbiAgICAgICAgY29uc3QgaXNFeHBvcnRlZCA9IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcodHlwZUFsaWFzLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCk7XG4gICAgICAgIGxldCBkZWNsOiB0cy5TdGF0ZW1lbnQ7XG4gICAgICAgIGlmIChpc0V4cG9ydGVkKSB7XG4gICAgICAgICAgLy8gR2l2ZW46IGV4cG9ydCB0eXBlIFQgPSAuLi47XG4gICAgICAgICAgLy8gV2UgY2Fubm90IGVtaXQgYGV4cG9ydCB2YXIgZm9vO2AgYW5kIGxldCBUUyBnZW5lcmF0ZSBmcm9tIHRoZXJlIGJlY2F1c2UgVHlwZVNjcmlwdFxuICAgICAgICAgIC8vIGRyb3BzIGV4cG9ydHMgdGhhdCBhcmUgbmV2ZXIgYXNzaWduZWQgdmFsdWVzLCBhbmQgQ2xvc3VyZSByZXF1aXJlcyB1cyB0byBub3QgYXNzaWduXG4gICAgICAgICAgLy8gdmFsdWVzIHRvIHR5cGVkZWYgZXhwb3J0cy4gSW50cm9kdWNpbmcgYSBuZXcgbG9jYWwgdmFyaWFibGUgYW5kIGV4cG9ydGluZyBpdCBjYW4gY2F1c2VcbiAgICAgICAgICAvLyBidWdzIGR1ZSB0byBuYW1lIHNoYWRvd2luZyBhbmQgY29uZnVzaW5nIFR5cGVTY3JpcHQncyBsb2dpYyBvbiB3aGF0IHN5bWJvbHMgYW5kIHR5cGVzXG4gICAgICAgICAgLy8gdnMgdmFsdWVzIGFyZSBleHBvcnRlZC4gTWFuZ2xpbmcgdGhlIG5hbWUgdG8gYXZvaWQgdGhlIGNvbmZsaWN0cyB3b3VsZCBiZSByZWFzb25hYmx5XG4gICAgICAgICAgLy8gY2xlYW4sIGJ1dCB3b3VsZCByZXF1aXJlIGEgdHdvIHBhc3MgZW1pdCB0byBmaXJzdCBmaW5kIGFsbCB0eXBlIGFsaWFzIG5hbWVzLCBtYW5nbGVcbiAgICAgICAgICAvLyB0aGVtLCBhbmQgZW1pdCB0aGUgdXNlIHNpdGVzIG9ubHkgbGF0ZXIuXG4gICAgICAgICAgLy8gU28gd2UgcHJvZHVjZTogZXhwb3J0cy5UO1xuICAgICAgICAgIGRlY2wgPSB0cy5jcmVhdGVTdGF0ZW1lbnQodHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgdHMuY3JlYXRlSWRlbnRpZmllcih0eXBlTmFtZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHaXZlbjogdHlwZSBUID0gLi4uO1xuICAgICAgICAgIC8vIFdlIHByb2R1Y2U6IHZhciBUO1xuICAgICAgICAgIC8vIE5vdGU6IG5vdCBjb25zdCwgYmVjYXVzZSAnY29uc3QgRm9vOycgaXMgaWxsZWdhbDtcbiAgICAgICAgICAvLyBub3QgbGV0LCBiZWNhdXNlIHdlIHdhbnQgaG9pc3RpbmcgYmVoYXZpb3IgZm9yIHR5cGVzLlxuICAgICAgICAgIGRlY2wgPSB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICAgICAgICBbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbih0cy5jcmVhdGVJZGVudGlmaWVyKHR5cGVOYW1lKSldKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjbCA9IHRzLnNldFNvdXJjZU1hcFJhbmdlKGRlY2wsIHR5cGVBbGlhcyk7XG4gICAgICAgIGFkZENvbW1lbnRPbihkZWNsLCB0YWdzLCBqc2RvYy5UQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSk7XG4gICAgICAgIHJldHVybiBbZGVjbF07XG4gICAgICB9XG5cbiAgICAgIC8qKiBFbWl0cyBhIHBhcmVudGhlc2l6ZWQgQ2xvc3VyZSBjYXN0OiBgKC8qKiBcXEB0eXBlIC4uLiAqIC8gKGV4cHIpKWAuICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVDbG9zdXJlQ2FzdChjb250ZXh0OiB0cy5Ob2RlLCBleHByZXNzaW9uOiB0cy5FeHByZXNzaW9uLCB0eXBlOiB0cy5UeXBlKSB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gdHMuY3JlYXRlUGFyZW4oZXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSBhZGRDb21tZW50T24oXG4gICAgICAgICAgICBpbm5lciwgW3t0YWdOYW1lOiAndHlwZScsIHR5cGU6IG1vZHVsZVR5cGVUcmFuc2xhdG9yLnR5cGVUb0Nsb3N1cmUoY29udGV4dCwgdHlwZSl9XSk7XG4gICAgICAgIGNvbW1lbnQuaGFzVHJhaWxpbmdOZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cy5zZXRTb3VyY2VNYXBSYW5nZSh0cy5jcmVhdGVQYXJlbihpbm5lciksIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICAvKiogQ29udmVydHMgYSBUeXBlU2NyaXB0IHR5cGUgYXNzZXJ0aW9uIGludG8gYSBDbG9zdXJlIENhc3QuICovXG4gICAgICBmdW5jdGlvbiB2aXNpdEFzc2VydGlvbkV4cHJlc3Npb24oYXNzZXJ0aW9uOiB0cy5Bc3NlcnRpb25FeHByZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihhc3NlcnRpb24udHlwZSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbG9zdXJlQ2FzdChhc3NlcnRpb24sIHRzLnZpc2l0RWFjaENoaWxkKGFzc2VydGlvbiwgdmlzaXRvciwgY29udGV4dCksIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGEgVHlwZVNjcmlwdCBub24tbnVsbCBhc3NlcnRpb24gaW50byBhIENsb3N1cmUgQ2FzdCwgYnkgc3RyaXBwaW5nIHxudWxsIGFuZFxuICAgICAgICogfHVuZGVmaW5lZCBmcm9tIGEgdW5pb24gdHlwZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXROb25OdWxsRXhwcmVzc2lvbihub25OdWxsOiB0cy5Ob25OdWxsRXhwcmVzc2lvbikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obm9uTnVsbC5leHByZXNzaW9uKTtcbiAgICAgICAgY29uc3Qgbm9uTnVsbFR5cGUgPSB0eXBlQ2hlY2tlci5nZXROb25OdWxsYWJsZVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbG9zdXJlQ2FzdChcbiAgICAgICAgICAgIG5vbk51bGwsIHRzLnZpc2l0RWFjaENoaWxkKG5vbk51bGwsIHZpc2l0b3IsIGNvbnRleHQpLCBub25OdWxsVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZpc2l0SW1wb3J0RGVjbGFyYXRpb24oaW1wb3J0RGVjbDogdHMuSW1wb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggaW1wb3J0LCBpbnNlcnQgYSBnb29nLnJlcXVpcmVUeXBlIGZvciB0aGUgbW9kdWxlLCBzbyB0aGF0IGlmIFR5cGVTY3JpcHQgZG9lcyBub3RcbiAgICAgICAgLy8gZW1pdCB0aGUgbW9kdWxlIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgaW4gdHlwZSBwb3NpdGlvbnMsIHRoZSBKU0RvYyBjb21tZW50cyBzdGlsbFxuICAgICAgICAvLyByZWZlcmVuY2UgYSB2YWxpZCBDbG9zdXJlIGxldmVsIHN5bWJvbC5cblxuICAgICAgICAvLyBObyBuZWVkIHRvIHJlcXVpcmVUeXBlIHNpZGUgZWZmZWN0IGltcG9ydHMuXG4gICAgICAgIGlmICghaW1wb3J0RGVjbC5pbXBvcnRDbGF1c2UpIHJldHVybiBpbXBvcnREZWNsO1xuXG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICAvLyBTY3JpcHRzIGRvIG5vdCBoYXZlIGEgc3ltYm9sLCBhbmQgbmVpdGhlciBkbyB1bnVzZWQgbW9kdWxlcy4gU2NyaXB0cyBjYW4gc3RpbGwgYmVcbiAgICAgICAgLy8gaW1wb3J0ZWQsIGVpdGhlciBhcyBzaWRlIGVmZmVjdCBpbXBvcnRzIG9yIHdpdGggYW4gZW1wdHkgaW1wb3J0IHNldCAoXCJ7fVwiKS4gVHlwZVNjcmlwdFxuICAgICAgICAvLyBkb2VzIG5vdCBlbWl0IGEgcnVudGltZSBsb2FkIGZvciBhbiBpbXBvcnQgd2l0aCBhbiBlbXB0eSBsaXN0IG9mIHN5bWJvbHMsIGJ1dCB0aGUgaW1wb3J0XG4gICAgICAgIC8vIGZvcmNlcyBhbnkgZ2xvYmFsIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBsaWJyYXJ5IHRvIGJlIHZpc2libGUsIHdoaWNoIGlzIHdoYXQgdXNlcnMgdXNlXG4gICAgICAgIC8vIHRoaXMgZm9yLiBObyBzeW1ib2xzIGZyb20gdGhlIHNjcmlwdCBuZWVkIHJlcXVpcmVUeXBlLCBzbyBqdXN0IHJldHVybi5cbiAgICAgICAgLy8gVE9ETyhldm1hcik6IHJldmlzaXQgdGhpcy4gIElmIFRTIG5lZWRzIHRvIHNlZSB0aGUgbW9kdWxlIGltcG9ydCwgaXQncyBsaWtlbHkgQ2xvc3VyZVxuICAgICAgICAvLyBkb2VzIHRvby5cbiAgICAgICAgaWYgKCFzeW0pIHJldHVybiBpbXBvcnREZWNsO1xuXG4gICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBnb29nbW9kdWxlLnJlc29sdmVNb2R1bGVOYW1lKFxuICAgICAgICAgICAge29wdGlvbnM6IHRzT3B0aW9ucywgbW9kdWxlUmVzb2x1dGlvbkhvc3Q6IGhvc3QubW9kdWxlUmVzb2x1dGlvbkhvc3R9LFxuICAgICAgICAgICAgc291cmNlRmlsZS5maWxlTmFtZSwgKGltcG9ydERlY2wubW9kdWxlU3BlY2lmaWVyIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQpO1xuXG4gICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLnJlcXVpcmVUeXBlKFxuICAgICAgICAgICAgaW1wb3J0UGF0aCwgc3ltLFxuICAgICAgICAgICAgLyogZGVmYXVsdCBpbXBvcnQ/ICovICEhaW1wb3J0RGVjbC5pbXBvcnRDbGF1c2UubmFtZSk7XG4gICAgICAgIHJldHVybiBpbXBvcnREZWNsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3N1cmUgQ29tcGlsZXIgd2lsbCBmYWlsIHdoZW4gaXQgZmluZHMgaW5jb3JyZWN0IEpTRG9jIHRhZ3Mgb24gbm9kZXMuIFRoaXMgZnVuY3Rpb25cbiAgICAgICAqIHBhcnNlcyBhbmQgdGhlbiByZS1zZXJpYWxpemVzIEpTRG9jIGNvbW1lbnRzLCBlc2NhcGluZyBvciByZW1vdmluZyBpbGxlZ2FsIHRhZ3MuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGVzY2FwZUlsbGVnYWxKU0RvYyhub2RlOiB0cy5Ob2RlKSB7XG4gICAgICAgIGNvbnN0IG1qc2RvYyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldE11dGFibGVKU0RvYyhub2RlKTtcbiAgICAgICAgbWpzZG9jLnVwZGF0ZUNvbW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIGV4cG9ydCBzaG91bGQgYmUgZW1pdHRlZCBmb3IgdGhlIGdpdmVuIHN5bWJvbCBpbiBleHBvcnQgKi4gKi9cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEVtaXRWYWx1ZUV4cG9ydEZvclN5bWJvbChzeW06IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgICBzeW0gPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RlOiBXZSBjcmVhdGUgZXhwbGljaXQgZXhwb3J0cyBvZiB0eXBlIHN5bWJvbHMgZm9yIGNsb3N1cmUgaW4gdmlzaXRFeHBvcnREZWNsYXJhdGlvbi5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0c09wdGlvbnMucHJlc2VydmVDb25zdEVudW1zICYmIHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNvbnN0RW51bSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB2aXNpdEV4cG9ydERlY2xhcmF0aW9uIHJlcXVpcmVUeXBlcyBleHBvcnRlZCBtb2R1bGVzIGFuZCBlbWl0cyBleHBsaWNpdCBleHBvcnRzIGZvclxuICAgICAgICogdHlwZXMgKHdoaWNoIG5vcm1hbGx5IGRvIG5vdCBnZXQgZW1pdHRlZCBieSBUeXBlU2NyaXB0KS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRFeHBvcnREZWNsYXJhdGlvbihleHBvcnREZWNsOiB0cy5FeHBvcnREZWNsYXJhdGlvbik6IHRzLk5vZGV8dHMuTm9kZVtdIHtcbiAgICAgICAgY29uc3QgaW1wb3J0ZWRNb2R1bGVTeW1ib2wgPSBleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllciAmJlxuICAgICAgICAgICAgdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllcikhO1xuICAgICAgICBpZiAoaW1wb3J0ZWRNb2R1bGVTeW1ib2wpIHtcbiAgICAgICAgICAvLyByZXF1aXJlVHlwZSBhbGwgZXhwbGljaXRseSBpbXBvcnRlZCBtb2R1bGVzLCBzbyB0aGF0IHN5bWJvbHMgY2FuIGJlIHJlZmVyZW5jZWQgYW5kXG4gICAgICAgICAgLy8gdHlwZSBvbmx5IG1vZHVsZXMgYXJlIHVzYWJsZSBmcm9tIHR5cGUgZGVjbGFyYXRpb25zLlxuICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLnJlcXVpcmVUeXBlKFxuICAgICAgICAgICAgICAoZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCwgaW1wb3J0ZWRNb2R1bGVTeW1ib2wsXG4gICAgICAgICAgICAgIC8qIGRlZmF1bHQgaW1wb3J0PyAqLyBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlc1RvRXhwb3J0OiBBcnJheTxbc3RyaW5nLCB0cy5TeW1ib2xdPiA9IFtdO1xuICAgICAgICBpZiAoIWV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlKSB7XG4gICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgICAgICAgIC8vIFJlc29sdmUgdGhlICogaW50byBhbGwgdmFsdWUgc3ltYm9scyBleHBvcnRlZCwgYW5kIHVwZGF0ZSB0aGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG4gICAgICAgICAgLy8gRXhwbGljaXRseSBzcGVsbGVkIG91dCBleHBvcnRzIChpLmUuIHRoZSBleHBvcnRzIG9mIHRoZSBjdXJyZW50IG1vZHVsZSkgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgICAgLy8gb3ZlciBpbXBsaWNpdCBvbmVzIGZyb20gZXhwb3J0ICouIFVzZSB0aGUgY3VycmVudCBtb2R1bGUncyBleHBvcnRzIHRvIGZpbHRlci5cbiAgICAgICAgICBjb25zdCBjdXJyZW50TW9kdWxlU3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzb3VyY2VGaWxlKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50TW9kdWxlRXhwb3J0cyA9IGN1cnJlbnRNb2R1bGVTeW1ib2wgJiYgY3VycmVudE1vZHVsZVN5bWJvbC5leHBvcnRzO1xuXG4gICAgICAgICAgaWYgKCFpbXBvcnRlZE1vZHVsZVN5bWJvbCkge1xuICAgICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoZXhwb3J0RGVjbCwgYGV4cG9ydCAqIHdpdGhvdXQgbW9kdWxlIHN5bWJvbGApO1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydERlY2w7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydGVkU3ltYm9scyA9IHR5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShpbXBvcnRlZE1vZHVsZVN5bWJvbCk7XG4gICAgICAgICAgY29uc3QgZXhwb3J0U3BlY2lmaWVyczogdHMuRXhwb3J0U3BlY2lmaWVyW10gPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN5bSBvZiBleHBvcnRlZFN5bWJvbHMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TW9kdWxlRXhwb3J0cyAmJiBjdXJyZW50TW9kdWxlRXhwb3J0cy5oYXMoc3ltLmVzY2FwZWROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgZ2VuZXJhdGVkIGFuIGV4cG9ydCBmb3IgdGhlIGdpdmVuIHN5bWJvbC5cbiAgICAgICAgICAgIGlmIChleHBhbmRlZFN0YXJJbXBvcnRzLmhhcyhzeW0ubmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZXhwYW5kZWRTdGFySW1wb3J0cy5hZGQoc3ltLm5hbWUpO1xuICAgICAgICAgICAgLy8gT25seSBjcmVhdGUgYW4gZXhwb3J0IHNwZWNpZmllciBmb3IgdmFsdWVzIHRoYXQgYXJlIGV4cG9ydGVkLiBGb3IgdHlwZXMsIHRoZSBjb2RlXG4gICAgICAgICAgICAvLyBiZWxvdyBjcmVhdGVzIHNwZWNpZmljIGV4cG9ydCBzdGF0ZW1lbnRzIHRoYXQgbWF0Y2ggQ2xvc3VyZSdzIGV4cGVjdGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChzaG91bGRFbWl0VmFsdWVFeHBvcnRGb3JTeW1ib2woc3ltKSkge1xuICAgICAgICAgICAgICBleHBvcnRTcGVjaWZpZXJzLnB1c2godHMuY3JlYXRlRXhwb3J0U3BlY2lmaWVyKHVuZGVmaW5lZCwgc3ltLm5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGVzVG9FeHBvcnQucHVzaChbc3ltLm5hbWUsIHN5bV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBvcnREZWNsID0gdHMudXBkYXRlRXhwb3J0RGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgIGV4cG9ydERlY2wsIGV4cG9ydERlY2wuZGVjb3JhdG9ycywgZXhwb3J0RGVjbC5tb2RpZmllcnMsXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZU5hbWVkRXhwb3J0cyhleHBvcnRTcGVjaWZpZXJzKSwgZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZXhwIG9mIGV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZE5hbWUgPSB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQoZXhwLm5hbWUpO1xuICAgICAgICAgICAgdHlwZXNUb0V4cG9ydC5wdXNoKFxuICAgICAgICAgICAgICAgIFtleHBvcnRlZE5hbWUsIG1vZHVsZVR5cGVUcmFuc2xhdG9yLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGV4cC5uYW1lKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgZW1pdCB0eXBlZGVmIHJlLWV4cG9ydHMgaW4gdW50eXBlZCBtb2RlLlxuICAgICAgICBpZiAoaG9zdC51bnR5cGVkKSByZXR1cm4gZXhwb3J0RGVjbDtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IHRzLk5vZGVbXSA9IFtleHBvcnREZWNsXTtcbiAgICAgICAgZm9yIChjb25zdCBbZXhwb3J0ZWROYW1lLCBzeW1dIG9mIHR5cGVzVG9FeHBvcnQpIHtcbiAgICAgICAgICBsZXQgYWxpYXNlZFN5bWJvbCA9IHN5bTtcbiAgICAgICAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgICAgIGFsaWFzZWRTeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzVHlwZUFsaWFzID0gKGFsaWFzZWRTeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDAgJiZcbiAgICAgICAgICAgICAgKGFsaWFzZWRTeW1ib2wuZmxhZ3MgJiAodHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzIHwgdHMuU3ltYm9sRmxhZ3MuSW50ZXJmYWNlKSkgIT09IDA7XG4gICAgICAgICAgaWYgKCFpc1R5cGVBbGlhcykgY29udGludWU7XG4gICAgICAgICAgY29uc3QgdHlwZU5hbWUgPVxuICAgICAgICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuZ2V0KGFsaWFzZWRTeW1ib2wpIHx8IGFsaWFzZWRTeW1ib2wubmFtZTtcbiAgICAgICAgICBjb25zdCBzdG10ID0gdHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJyksIGV4cG9ydGVkTmFtZSkpO1xuICAgICAgICAgIGFkZENvbW1lbnRPbihzdG10LCBbe3RhZ05hbWU6ICd0eXBlZGVmJywgdHlwZTogJyEnICsgdHlwZU5hbWV9XSk7XG4gICAgICAgICAgdHMuYWRkU3ludGhldGljVHJhaWxpbmdDb21tZW50KFxuICAgICAgICAgICAgICBzdG10LCB0cy5TeW50YXhLaW5kLlNpbmdsZUxpbmVDb21tZW50VHJpdmlhLCAnIHJlLWV4cG9ydCB0eXBlZGVmJywgdHJ1ZSk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RtdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBpZGVudGlmaWVycyBleHBvcnRlZCBpbiBhIHNpbmdsZSBleHBvcnRlZCBzdGF0ZW1lbnQgLSB0eXBpY2FsbHkganVzdCBvbmVcbiAgICAgICAqIGlkZW50aWZpZXIgKGUuZy4gZm9yIGBleHBvcnQgZnVuY3Rpb24gZm9vKClgKSwgYnV0IG11bHRpcGxlIGZvciBgZXhwb3J0IGRlY2xhcmUgdmFyIGEsIGJgLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBnZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKG5vZGU6IHRzLk5vZGUpOiB0cy5JZGVudGlmaWVyW10ge1xuICAgICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDpcbiAgICAgICAgICAgIGNvbnN0IHZhckRlY2wgPSBub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHZhckRlY2wuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5tYXAoKGQpID0+IGdldEV4cG9ydERlY2xhcmF0aW9uTmFtZXMoZClbMF0pO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTW9kdWxlRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkVudW1EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIGNvbnN0IGRlY2wgPSBub2RlIGFzIHRzLk5hbWVkRGVjbGFyYXRpb247XG4gICAgICAgICAgICBpZiAoIWRlY2wubmFtZSB8fCBkZWNsLm5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtkZWNsLm5hbWVdO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIGNvbnN0IHR5cGVBbGlhcyA9IG5vZGUgYXMgdHMuVHlwZUFsaWFzRGVjbGFyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gW3R5cGVBbGlhcy5uYW1lXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoXG4gICAgICAgICAgICBub2RlLCBgdW5zdXBwb3J0ZWQgZXhwb3J0IGRlY2xhcmF0aW9uICR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfTogJHtub2RlLmdldFRleHQoKX1gKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFtYmllbnQgZGVjbGFyYXRpb25zIGRlY2xhcmUgdHlwZXMgZm9yIFR5cGVTY3JpcHQncyBiZW5lZml0LCBhbmQgd2lsbCBiZSByZW1vdmVkIGJ5XG4gICAgICAgKiBUeXBlU2NyaXB0IGR1cmluZyBpdHMgZW1pdCBwaGFzZS4gRG93bnN0cmVhbSBDbG9zdXJlIGNvZGUgaG93ZXZlciBtaWdodCBiZSBpbXBvcnRpbmdcbiAgICAgICAqIHN5bWJvbHMgZnJvbSB0aGlzIG1vZHVsZSwgc28gdHNpY2tsZSBtdXN0IGVtaXQgYSBDbG9zdXJlLWNvbXBhdGlibGUgZXhwb3J0cyBkZWNsYXJhdGlvbi5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRFeHBvcnRlZEFtYmllbnQobm9kZTogdHMuTm9kZSk6IHRzLk5vZGVbXSB7XG4gICAgICAgIGlmIChob3N0LnVudHlwZWQgfHwgIXNob3VsZEVtaXRFeHBvcnRzQXNzaWdubWVudHMoKSkgcmV0dXJuIFtub2RlXTtcblxuICAgICAgICBjb25zdCBkZWNsTmFtZXMgPSBnZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKG5vZGUpO1xuICAgICAgICBjb25zdCByZXN1bHQ6IHRzLk5vZGVbXSA9IFtub2RlXTtcbiAgICAgICAgZm9yIChjb25zdCBkZWNsIG9mIGRlY2xOYW1lcykge1xuICAgICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oZGVjbCkhO1xuICAgICAgICAgIC8vIE5vbi12YWx1ZSBvYmplY3RzIGRvIG5vdCBleGlzdCBhdCBydW50aW1lLCBzbyB3ZSBjYW5ub3QgYWNjZXNzIHRoZSBzeW1ib2wgKGl0IG9ubHlcbiAgICAgICAgICAvLyBleGlzdHMgaW4gZXh0ZXJucykuIEV4cG9ydCB0aGVtIGFzIGEgdHlwZWRlZiwgd2hpY2ggZm9yd2FyZHMgdG8gdGhlIHR5cGUgaW4gZXh0ZXJucy5cbiAgICAgICAgICAvLyBOb3RlOiBUeXBlU2NyaXB0IGVtaXRzIG9kZCBjb2RlIGZvciBleHBvcnRlZCBhbWJpZW50cyAoZXhwb3J0cy54IGZvciB2YXJpYWJsZXMsIGp1c3QgeFxuICAgICAgICAgIC8vIGZvciBldmVyeXRoaW5nIGVsc2UpLiBUaGF0IHNlZW1zIGJ1Z2d5LCBhbmQgaW4gZWl0aGVyIGNhc2UgdGhpcyBjb2RlIHNob3VsZCBub3QgYXR0ZW1wdFxuICAgICAgICAgIC8vIHRvIGZpeCBpdC5cbiAgICAgICAgICAvLyBTZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzgwMTUuXG4gICAgICAgICAgaWYgKCFzeW1ib2xJc1ZhbHVlKHR5cGVDaGVja2VyLCBzeW0pKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgZW1pdCByZS1leHBvcnRzIGZvciBNb2R1bGVEZWNsYXJhdGlvbnMuXG4gICAgICAgICAgICAvLyBBbWJpZW50IE1vZHVsZURlY2xhcmF0aW9ucyBhcmUgYWx3YXlzIHJlZmVyZW5jZWQgYXMgZ2xvYmFsIHN5bWJvbHMsIHNvIHRoZXkgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICAgICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmdsZWROYW1lID0gbW9kdWxlTmFtZUFzSWRlbnRpZmllcihob3N0LCBzb3VyY2VGaWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2xOYW1lID0gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KGRlY2wpO1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IHRzLmNyZWF0ZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJyksIGRlY2xOYW1lKSk7XG4gICAgICAgICAgICBhZGRDb21tZW50T24oc3RtdCwgW3t0YWdOYW1lOiAndHlwZWRlZicsIHR5cGU6IGAhJHttYW5nbGVkTmFtZX0uJHtkZWNsTmFtZX1gfV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZTogdHMuTm9kZSk6IHRzLk5vZGV8dHMuTm9kZVtdIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5pc0FtYmllbnQobm9kZSkpIHtcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobm9kZSBhcyB0cy5EZWNsYXJhdGlvbiwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0RXhwb3J0ZWRBbWJpZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkltcG9ydERlY2xhcmF0aW9uOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0SW1wb3J0RGVjbGFyYXRpb24obm9kZSBhcyB0cy5JbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cG9ydERlY2xhcmF0aW9uOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0RXhwb3J0RGVjbGFyYXRpb24obm9kZSBhcyB0cy5FeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGUgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0SW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkhlcml0YWdlQ2xhdXNlOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0SGVyaXRhZ2VDbGF1c2Uobm9kZSBhcyB0cy5IZXJpdGFnZUNsYXVzZSk7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkFycm93RnVuY3Rpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIC8vIEluc2VydGluZyBhIGNvbW1lbnQgYmVmb3JlIGFuIGV4cHJlc3Npb24gY2FuIHRyaWdnZXIgYXV0b21hdGljIHNlbWljb2xvbiBpbnNlcnRpb24sXG4gICAgICAgICAgICAvLyBlLmcuIGlmIHRoZSBmdW5jdGlvbiBiZWxvdyBpcyB0aGUgZXhwcmVzc2lvbiBpbiBhIGByZXR1cm5gIHN0YXRlbWVudC4gUGFyZW50aGVzaXppbmdcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIEFTSSwgYXMgbG9uZyBhcyB0aGUgb3BlbmluZyBwYXJlbiByZW1haW5zIG9uIHRoZSBzYW1lIGxpbmUgKHdoaWNoIGl0IGRvZXMpLlxuICAgICAgICAgICAgcmV0dXJuIHRzLmNyZWF0ZVBhcmVuKFxuICAgICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25MaWtlRGVjbGFyYXRpb24obm9kZSBhcyB0cy5BcnJvd0Z1bmN0aW9uIHwgdHMuRnVuY3Rpb25FeHByZXNzaW9uKSk7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5NZXRob2REZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuR2V0QWNjZXNzb3I6XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb25MaWtlRGVjbGFyYXRpb24obm9kZSBhcyB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlRoaXNLZXl3b3JkOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0VGhpc0V4cHJlc3Npb24obm9kZSBhcyB0cy5UaGlzRXhwcmVzc2lvbik7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0VmFyaWFibGVTdGF0ZW1lbnQobm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudCk7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5RGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5QXNzaWdubWVudDpcbiAgICAgICAgICAgIGVzY2FwZUlsbGVnYWxKU0RvYyhub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5QYXJhbWV0ZXI6XG4gICAgICAgICAgICAvLyBQYXJhbWV0ZXIgcHJvcGVydGllcyAoZS5nLiBgY29uc3RydWN0b3IoLyoqIGRvY3MgKi8gcHJpdmF0ZSBmb286IHN0cmluZylgKSBtaWdodCBoYXZlXG4gICAgICAgICAgICAvLyBKU0RvYyBjb21tZW50cywgaW5jbHVkaW5nIEpTRG9jIHRhZ3MgcmVjb2duaXplZCBieSBDbG9zdXJlIENvbXBpbGVyLiBQcmV2ZW50IGVtaXR0aW5nXG4gICAgICAgICAgICAvLyBhbnkgY29tbWVudHMgb24gdGhlbSwgc28gdGhhdCBDbG9zdXJlIGRvZXNuJ3QgZXJyb3Igb24gdGhlbS5cbiAgICAgICAgICAgIC8vIFNlZSB0ZXN0X2ZpbGVzL3BhcmFtZXRlcl9wcm9wZXJ0aWVzLnRzLlxuICAgICAgICAgICAgY29uc3QgcGFyYW1EZWNsID0gbm9kZSBhcyB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lclV0aWwuaGFzTW9kaWZpZXJGbGFnKFxuICAgICAgICAgICAgICAgICAgICBwYXJhbURlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuUGFyYW1ldGVyUHJvcGVydHlNb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHBhcmFtRGVjbCwgW10pO1xuICAgICAgICAgICAgICBqc2RvYy5zdXBwcmVzc0xlYWRpbmdDb21tZW50c1JlY3Vyc2l2ZWx5KHBhcmFtRGVjbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXNFeHByZXNzaW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdEFzc2VydGlvbkV4cHJlc3Npb24obm9kZSBhcyB0cy5UeXBlQXNzZXJ0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTm9uTnVsbEV4cHJlc3Npb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXROb25OdWxsRXhwcmVzc2lvbihub2RlIGFzIHRzLk5vbk51bGxFeHByZXNzaW9uKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2VGaWxlID0gdHMudmlzaXRFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXRvciwgY29udGV4dCk7XG5cbiAgICAgIHJldHVybiBtb2R1bGVUeXBlVHJhbnNsYXRvci5pbnNlcnRBZGRpdGlvbmFsSW1wb3J0cyhzb3VyY2VGaWxlKTtcbiAgICB9O1xuICB9O1xufVxuIl19